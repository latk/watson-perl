#!/usr/bin/perl
package Watson;
# watson - inline issue manager
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# This content is licensed under the MIT License
# See the file LICENSE for copying permission


# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - wrap printed lines around 80 characters
# [todo] - command line option to remove remote repos
# [todo] - replace json parser with just grep? need to get status if failed
# [todo] - add ability to update issue if same title but different md5
# [todo] - implement local only reporting (make it default?)
# [todo] - progress bar for obtaining github/bitbucket issue list
# [todo] - local should be default, must use -r or remote flag to post and check?
#		 - maybe have it check against background unless -local is passed
#		 - but dont post unless --post is used (make it faster?)
# [todo] - add status indicator for remote requests
#		 - we know # of requests and which we are on, can do it that way
# [todo] - change github issue checks to -d instead of issue?key=val
# [todo] - add remote / local options and necessary logic
# [todo] - replace open/closed issue var with just all and closed?

###########################################################
# Global parameters
###########################################################

use strict;
use feature qw/say/;  # implies dependency on perl 5.010
use autodie; # in Core since 5.010
use warnings;

# For color print outs
use Term::ANSIColor qw(:constants);

# Route Ctrl-C to cExit to clean up results
$SIG{'INT'} = \&cExit;

# For debugging (print data structures)
use Data::Dumper;

# For MD5 Sum (issue posting check)
use Digest::MD5 qw(md5_hex);

use JSON ();  # [todo] - list JSON as external dependency
# [todo] - list LWP::UserAgent as external dependency

use File::Copy ();   # in Core since 5.002
use MIME::Base64 (); # in Core since 5.007.003
use Carp ();         # in Core since 5.000
use Encode ();       # in Core since 5.007.003

# App Config
our $DEBUG = $ENV{WATSON_DEBUG};
our $RCNAME = ".watsonrc";		# Change config file name
our $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
our @DIRS;
our @FILES;
our @TAGS;
our @IGNORE;
our @STRUCTURE;
our $REMOTESETUP = 0;
our $MAX_DEPTH = 0;
our $IGNORE_RC_DIRS = 0;
our $IGNORE_RC_FILES = 0;
our $IGNORE_RC_TAGS = 0;
our $IGNORE_RC_IGNORE = 0;
our $HASLESS = 0;
our $HASCURL = 0;
our $LESSOUT;

our $GITHUB    = Watson::Repository::GitHub->new;
our $BITBUCKET = Watson::Repository::Bitbucket->new;

our %REPOSITORIES = (
	github    => $GITHUB,
	bitbucket => $BITBUCKET,
);


#----------------------------------------------------------
###########################################################
# Main Program
###########################################################
#----------------------------------------------------------

checkLess();
checkcURL();
printHeader();
parseCommandLine();
checkConfig();
parseConfig();
startScan();
createReport();


#----------------------------------------------------------
###########################################################
# Functions
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print
###########################################################

sub header {
	unshift @_, '' if @_;  # adds an empty line before further info
	# Each line is a string or an arrayref of strings
	# Here, we flatten them (if applicable), add a newline,
	# and return a single string.
	return join '', map { join '', ( ref $_ ? @$_ : $_ ), "\n" }
		[BOLD "------------------------------"],
		[BOLD "watson", RESET, " - ", BOLD YELLOW "inline issue manager", RESET],
		@_,
		[BOLD "------------------------------"],
		'';
}

sub printHeader {
	chomp(my $pwd = `pwd`);
	my $time = localtime;
	wprint(header("Run in: $pwd", "Run \@: $time"), "\n");
	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub printHelp {
	print BOLD, <<'END_HELP', RESET;
Usage: watson [OPTION]...
Running watson with no arguments will parse with settings in RC file
If no RC file exists, default RC file will be created

   -d, --dirs			list of directories to search in
   -f, --files			list of files to search in
   -h, --help			say help
   -i, --ignore			list of files, directories, or types to ignore
   -p, --parse-depth		depth to recursively parse directories
   -r, --remote			list / create tokens for Bitbucket/Github
   -t, --tags			list of tags to search for
   -v, --version		say watson version and info

Any number of files, tags, dirs, and ignores can be listed after flag
Ignored files should be space separated
To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions


Report bugs to: watson\@goosecode.com
watson home page: <http://goosecode.com/projects/watson>
[goosecode] labs | 2012-2013";
END_HELP

	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub printVersion {
	print <<'END_VERSION';
watson v1.3
Copyright (c) 2012-2013 goosecode labs
Licensed under MIT, see LICENSE for details

Written by nhmood, see <http://goosecode.com/projects/watson>
END_VERSION

	return 1;
}


###########################################################
# Clean Exit
###########################################################

# Clean exit function that removes temp files
sub cExit {
	my ($exit_status) = @_;

	unlink $TMPOUT or warn "Could not remove $TMPOUT: $!";

	# If exit status is INT(terupt), set to 1 and print newline
	if ($exit_status eq "INT"){
		$exit_status = 1;
		print "\n";
	}
	exit $exit_status;
}


###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debugPrint {
	print @_ if $DEBUG;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	if ($HASLESS){
		print $LESSOUT @_;
		return 1;
	}
	else {
		print @_;
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub checkLess {
	return $HASLESS if defined $HASLESS;
	$HASLESS //= !system("which less > /dev/null 2>&1") or return 0;
	open $LESSOUT, "+>", $TMPOUT;
	return 1;
}


###########################################################
# cURL Checker
###########################################################

# Check to see if system has cURL
# If so, set flag
sub checkcURL {
	return $HASCURL //= !system("which curl > /dev/null 2>&1");
}


###########################################################
# Directory checker
###########################################################

# checkDir - checks if directory can be opened
# Different from just using -d, checks if able to OPEN
sub checkDir {
	my ($dir) = @_;

	# Error check for input
	unless (length $dir) {
		wprint("No directories specified.\n");
		return 0;
	}

	# Check if directory can be opened
	opendir my $tDIR, $dir or do {
		wprint(qq{Cannot open dir "$dir": $!\n});
		return 0;
	};

	closedir $tDIR;
	debugPrint(qq{"$dir" exists and opened successfully.\n});
	return 1;
}


###########################################################
# File checker
###########################################################

# checkFile - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub checkFile {
	my ($file) = @_;

	# Error check for input
	unless (length $file) {
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	open my $tFILE, $file or do {
		wprint(qq{Could not open "$file": $!\n});
		return 0;
	};

	close $tFILE;
	debugPrint(qq{"$file"" exists and opened successfully.\n});
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub checkConfig {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects

	# Check for rc
	debugPrint("[Checking for $RCNAME]\n");
	if (-e $RCNAME) {
		debugPrint("$RCNAME found\n\n");
		return 1;
	}
	else {
		debugPrint("$RCNAME not found!\n");
		debugPrint("Creating default $RCNAME\n");

		# Create default rc
		createRC($RCNAME);
		return 0;
	}
}


###########################################################
# Default config file writer
###########################################################

# Create default RC file with some generic settings
sub createRC {
	my ($file_name) = @_;
	open my $file, "+>>", $file_name;

# [fixme] - Figure out a way to indent this?
my $rcdefault = <<'EOF';
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories
[dirs]
./


# Tags
[tags]
fix
review
todo


# Ignores
[ignore]
.git
.swp
EOF

	debugPrint($rcdefault);
	# Print default rc above to specified file
	my $success = print $file $rcdefault;
	close($file);
	return $success;
}


###########################################################
# Command line parser
###########################################################

# Parse command line arguments
sub parseCommandLine {
	debugPrint("[Checking CL args]\n");
	debugPrint("Total args: ", $#ARGV + 1, "\n");

	my %long_opts = (
		"-d" => "--dirs",
		"-f" => "--files",
		"-h" => "--help",
		"-v" => "--version",
		"-t" => "--tags",
		"-p" => "--parse-depth",
		"-i" => "--ignore",
		"-r" => "--remote",
		"-u" => "--update"
	);
	my %opts;
	@opts{%long_opts} = ();

	my $slurp_items = sub {
		my ($cb) = @_;
		my $count = 0;

		# Keep checking following options until another flag or end
		while (@ARGV) {
			if (exists $opts{$ARGV[0]}) {
				debugPrint("Found a flag: $ARGV[0]\n");
				last;
			}

			my $item = shift @ARGV;
			$cb->($item);
		}
	};

	my %flag_actions = (
		'--help' => sub {
			debugPrint("Help flag passed\n");
			printHelp();
			cExit(0);
		},
		'--version' => sub {
			debugPrint("Version flag passed\n");
			printVersion();
			cExit(0);
		},
		'--parse-depth' => sub {
			debugPrint("Parse Depth flag passed\n");
			# Check to make sure next param is a valid number (non-negative)

			unless (@ARGV) {
				wprint(box(BOLD RED "x"), "--parse-depth requires a numeric argument\n");
			}

			my $depth = shift @ARGV;

			if ($depth =~ /[^0-9]/) {
				wprint(box(BOLD MAGENTA "!"));
				wprint("--> ", RESET);
				wprint("Invalid parse depth passed\n");
				return;
			}

			$MAX_DEPTH = $depth;
			debugPrint("Valid parse depth: $MAX_DEPTH\n");
		},
		'--remote' => sub {
			debugPrint("Remote Flag passed\n");

			# When generating OAuth Token for github/bitbucket
			# no other params should be passed
			if (@ARGV > 1){
				debugPrint("Not the only flag, exiting\n");
				print box(BOLD RED "x");
				print "Please run remote flag alone to generate GitHub/Bitbucket OAuth token\n";
				print "      See help for more details\n";
				cExit(1);
			}

			# Can only do this if we have cURL on the system
			unless ($HASCURL) {
				print box(BOLD RED "x");
				print "It looks like you don't have cURL\n";
				print "      We currently only support remote issues if you have cURL\n";
				print "      Make sure cURL is installed and in your PATH\n";
				cExit(1);
			}

			my $service = lc shift @ARGV;

			if (my $repo = $REPOSITORIES{$service}) {
				$repo->setup;
			}
			elsif ($service eq "") {
				parseConfig() if checkConfig();

				if (not defined $BITBUCKET->access_token and not defined $GITHUB->access_token) {
					say box_error("No remotes currently exist");
					say BOLD "      Pass github or bitbucket to watson -r to add", RESET;
					say "      That's all we support right now :(";
					say "      See help for more details";
					cExit(1);
				}

				if (defined $BITBUCKET->access_token) {
					print box(BOLD GREEN "Bitbucket"), "\n";
					say BOLD "   Bitbucket User :", RESET, " ", $BITBUCKET->access_token;
					say BOLD "   Bitbucket Repo :", RESET, " ", $BITBUCKET->repo;
					say "";
				}

				if (defined $GITHUB->access_token) {
					say box(BOLD GREEN "GitHub");
					say BOLD "   GitHub Key  :", RESET, " ", $GITHUB->access_token;
					say BOLD "   GitHub Repo :", RESET, " ", $GITHUB->repo;
					say "";
				}

				cExit(1);
			}
			else {
				say box_error("Incorrect argument");
				say for
					"      Please specify either github or bitbucket to setup remote",
					"      Or pass without argument to see current remotes",
					"      See help for more details";
				cExit(1);
			}
		},
		'--dirs' => sub {
			debugPrint("Dir flag passed\n");
			$slurp_items->(sub {
				my ($dir) = @_;
				debugPrint("Dir Index: $dir\n");

				if (checkDir($dir)) {
					debugPrint("dirflag: {$dir} valid directory, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debugPrint("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC_DIRS = 1;

					# Remove trailing slashes
					$dir =~ s{/+\z}{};
					push @DIRS, $dir;
				}
			});
		},
		'--files' => sub {
			debugPrint("File flag passed\n");
			$slurp_items->(sub {
				my ($file) = @_;
				debugPrint("File Index: $file\n");

				if (checkFile($file)) {
					debugPrint("fileflag: {$file} valid file, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debugPrint("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC_FILES = 1;

					push @FILES, $file;
					}
			});
		},
		'--tags' => sub {
			debugPrint("Tag flag passed\n");
			$slurp_items->(sub {
				my ($tag) = @_;
				debugPrint("Tag Index: $tag\n");
				debugPrint("tagflag: {$tag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debugPrint("Ignoring RC tags\n\n");
				$IGNORE_RC_TAGS = 1;

				push @TAGS, $tag;
			});
		},
		'--ignore' => sub {
			debugPrint("Tag flag passed\n");
			$slurp_items->(sub {
				my ($ignoreflag) = @_;
				debugPrint("Ignore Index: $ignoreflag\n");
				debugPrint("ignoreflag: {$ignoreflag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debugPrint("Ignoring RC ignore\n\n");
				$IGNORE_RC_IGNORE = 1;

				push @IGNORE, $ignoreflag;
			});
		},
	);
	for my $key (keys %long_opts) {
		$flag_actions{$key} = $flag_actions{$long_opts{$key}};
		exists $flag_actions{$key}
			or warn "The option $long_opts{$key} is not implemented";
	}

	unless (@ARGV) {
		debugPrint("No command line arguments passed.\n\n");
		return;
	}

	while (@ARGV) {
		my $item = shift @ARGV;
		debugPrint("Main Item: $item\n");

		if (my $action = $flag_actions{$item}) {
			$action->();
		}
		else {
			die qq{Can't understand command line argument "$item"};
		}
	}
	return 1;
}


###########################################################
# Config file parser
###########################################################

BEGIN {
	package Watson::Configuration;

	sub new_from_file {
		my ($class, $filename) = @_;
		open my $fh, "<", $filename;

		my %sections;

		my $section;
		while (<$fh>) {
			chomp;
			Watson::debugPrint("# line $.: $_\n");

			next if !/\S/;
			next if /\A\s*#/;

			if (/\A\[(\w+)\]\s*\z/) {
				$section = lc $1;
				Watson::debugPrint("# recognized as section [$section]\n");
				next;
			}

			die qq/No section specified at "$filename" line $../
				unless defined $section;

			push @{ $sections{$section} }, $_;
			Watson::debugPrint("# added to [$section]\n");
		}

		return bless {
			sections => \%sections,
		} => $class;
	}

	sub sections {
		my $self = shift;
		return $self->{sections};
	}

	sub section {
		my $self = shift;
		Carp::croak qq/Argument "name" is required/ unless @_;
		my $name = shift;
		Carp::croak "name must be defined" unless defined $name;
		return $self->{sections}{$name} if exists $self->{sections}{$name};
		return my $default = shift if @_;
		Carp::croak qq/No entry for "$name" present, and no default given/;
	}

	sub section_names {
		my $self = shift;
		return keys %{ $self->{sections} };
	}

	sub replace_sections {
		my (undef, $filename, %replacements) = @_;

		# First, delete the old sections if applicable:

		my $nlc = 0;
		if (Watson::checkConfig()){
			open my $in,  "<", $filename;
			open my $out, ">", "$filename.new";

			my $section = "";
			while (<$in>){
				chomp;
				$section = lc $1 if /^\[(\w+)\]/;

				# Max 2 consecutive empty lines
				if (!/\S/ and ++$nlc <= 2) {
					say $out "";
					next;
				}

				next if exists $replacements{$section};

				# This section won't be changed - copy everything over.
				say $out $_;
				$nlc = 0;  # Reset newline count
			}

			# Remove old RC file and replace with new one
			File::Copy::move("$filename.new" => $filename)
				or die qq{Can't move update RC at "$filename": $!};
		}

		# Now, append the new sections to the file (new or old, doesn't matter)

		open my $file, ">>", $filename;


		for my $section (sort keys %replacements) {
			# print remaining newlines
			say $file "" for $nlc .. 1;

			say $file "[$section]";
			say $file $_ for @{ $replacements{$section} };

			$nlc = 0;
		}
		close $file;
	}
}

# Go through config file and determine dirs, tags, and ignores to use
sub parseConfig {
	# Parse rc
	debugPrint("Parsing $RCNAME\n");

	# Add . and .. and .git to ignorelist
	push @IGNORE, ".", "..", "*.swp", ".watsonrc", $TMPOUT;

	my %actions = (
		# If @DIRS or @FILES wasn't populated by CL args, populate from rc
		dirs => sub {
			my $name = shift;
			if ($IGNORE_RC_DIRS || $IGNORE_RC_FILES) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for dirs, then push to @DIRS
				$line =~ m{\A\s* ((?:\.?/?\w?+/?)+) \s*\z}x
					or die qq{The line "$line" in a "dirs" section did not contain a valid path};
				(my $dir = $1) =~ s{/+\z}{};
				debugPrint("dirs: $dir added from rc. \n");
				push @DIRS, $dir;
			}
		},
		# If @TAGS wasn't populated by CL args, populate from rc
		tags => sub {
			my $name = shift;
			if ($IGNORE_RC_TAGS) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for tags, then push to @TAGS
				$line =~ /^\A\s* (\w+(?: \| [0-9])?) \s*\z/x
					or die qq{The line "$line" in a "tags" section did not contain a valid tag};
				my $tag = $1;
				debugPrint("tags: $tag added from rc.\n");
				push @TAGS, $tag;
			}
		},
		# If @IGNORE wasn't populated by CL args, populate from rc
		ignore => sub {
			my $name = shift;
			my ($line) = @_;
			if ($IGNORE_RC_IGNORE) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for dirs to ignore, then push to @IGNOREDIR
				$line =~ m{\A\s* (.+) \s*\z}x
					or die qq{The line "$line" in a "ignore" section did not contain a valid path};
				(my $path = $1) =~ s{(/)+\z}{};
				debugPrint("ignore: $path added from rc.\n");
				push @IGNORE, $path;
			}
		},
		github => sub {
			my $name = shift;
			my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

			for my $api (@_) {
				say box_warn("The ", $repository->name, " API was already set, overwriting")
					if defined $repository->access_token;

				# No need for regex on API key
				debugPrint($repository->name . "API: $api\n");
				$repository->access_token($api);
			}
		},
		githubrepo => sub {
			my $name = shift;
			$name =~ s/repo\z//;
			my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

			for my $repo (@_) {
				say box_warn("The ", $repository->name, "Repo was already set, overwriting")
					if defined $repository->repo;

				# No need for regex on repo
				debugPrint($repository->name . "Repo: $repo\n");
				$repository->repo($repo);
			}

			# If setting up remote, don't ask for password / do any remote stuff
			# Won't need this when OAuth implemented but it does optimize the code...

			# Get list of issues, also checks if API key is valid
			$repository->fetch_issues unless $REMOTESETUP;
		},
	);
	$actions{bitbucket}     = $actions{github};
	$actions{bitbucketrepo} = $actions{githubrepo};

	my $config = Watson::Configuration->new_from_file($RCNAME);

	for my $section ($config->section_names) {
		my $action = $actions{$section} or die qq/Unknown section "$section"/;
		debugPrint("[$section] contains [@{[$config->section($section)]}]\n");
		$action->($section => $_) for @{ $config->section($section) };
	}

	return 1;
}


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub startScan{

	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC_FILES){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		push @STRUCTURE, {
			files => [ map { parseFile($_) } @FILES ],
		};
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	push @STRUCTURE, map { parseDirs($_) } @DIRS;

	wprint("\n");
	return 1;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parseDirs {
	my ($dir, $depth) = @_;
	$depth //= 1;
	return if $MAX_DEPTH and $depth > $MAX_DEPTH;
	debugPrint("parseDirs: |$dir| at depth $depth/$MAX_DEPTH\n");
	return unless checkDir($dir); # Error check for input

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	# Loop through all entries in directory
	debugPrint(qq{Looping through all files/folders in "$dir"\n});

	# Open dir and get list of all files
	opendir(my $wd, $dir);
	ENTRY: for my $entry (sort grep !/\A\.\.?\z/, readdir $wd) {
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		debugPrint("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		for my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so
			($ignore) = map qr/\A$_\z/, join '.*', map quotemeta, split /[*]/, $ignore
				unless ref $ignore;
			if ($entry =~ /$ignore/) {
				debugPrint("|$path| is on the ignore list, skipping\n");
				next ENTRY;
			}
		}

		# Check if entry is a file, if so parse
		if (-f $path) {
			debugPrint("|$path| is a file!\n");
			push @pfiles, parseFile($path);
		}
		# Check if entry is dir, if so parse
		elsif (-d $path) {
			debugPrint("|$path| is a dir!\n");
			push @pdirs, parseDirs($path, $depth + 1);
		}

		# Add directory to ignore list so it isn't repeated again
		push @IGNORE, $path;
	}

	closedir $wd;
	# Create has to hold all parsed files and folders
	return {
		files => \@pfiles,
		dirs => \@pdirs,
	};
}


###########################################################
# File Parser
###########################################################

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debugPrint("parseFile: |$file|\n");

	# Error check for input
	return unless checkFile($file);

	# Get filetype and set corresponding comment type
	my $comment = getComment($file);

	# Open file and seek to beginning
	open my $wf, "<", $file;
	seek $wf, 0, 0;

	my %issueList = (
		filename => $file,
		(map { $_ => [] } @TAGS),
	);

	# Read source file line by line
	while (my $line = <$wf>){
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /\s*(?:$comment)+\s*\[(\S+)\]\s*-\s*(.+)/) {
			my ($ftag, $fissue) = ($1, $2);
			debugPrint("Issue found!\n");
			debugPrint("Tag: $ftag\n");
			debugPrint("Issue: $fissue\n");

			next unless exists $issueList{$ftag};

			# Create hash for each issue found (for each tag)
			my %issue = (
				linenumber => $.,
				comment => $fissue,
				tag => $ftag,
				file => $file,
			);

			# Create hash for specific issue
			my $digest = md5_hex(@issue{qw/tag file comment/});
			debugPrint("$digest\n");
			$issue{md5} = $digest;

			push @{$issueList{$ftag}}, \%issue;

			$GITHUB->post_issue(\%issue)    if $GITHUB->valid;
			$BITBUCKET->post_issue(\%issue) if $BITBUCKET->valid;
	    }
	}

	return \%issueList;
}


###########################################################
# Comment setter
###########################################################

# Determine comment type from file extension
sub getComment {
	my ($file) = @_;
	debugPrint("Getting comment type\n");

	# Grab the ending extension (.something)
	# Check to see whether it is recognized and set comment type
	# If unrecognized, try to grab next .something extension
	# This is to account for file.cpp.1 or file.cpp.bak, ect

	my %exts;
	$exts{$_} = qr{//} for qw/cpp cc c h c++/; # [todo] - add /* style comment
	$exts{$_} = qr{#}  for qw/sh rb pl pm/;

	my (undef, @extensions) = grep !/\s/, split /\./, $file;
	for my $ext (reverse @extensions) {
		# Regex for last extension
		debugPrint("Extension: $ext\n");
		return $exts{$ext} // next;
	}

	print box(BOLD MAGENTA "!");
	print("--> ", RESET);
	print("Couldn't determine filetype for $file, using # as comment\n", RESET);

	# Didn't find any match, return error (and just use #)
	return qr{#};
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub createReport {
	# Display output for each file parsed
	for my $entry (@STRUCTURE){
		printResults($entry);
	}

	if ($HASLESS){
		system("less -R $TMPOUT");
		close($LESSOUT);
		system("rm $TMPOUT > /dev/null 2>&1");
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub printResults {
	my ($entry) = @_;
	# Go through and print info for all files first
	for my $file_report (@{$entry->{files}}) {

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = grep { 0+@{$file_report->{$_}} } @TAGS;

		if ($issueflag){
			wprint("\n");
			wprint(box_error(UNDERLINE $file_report->{filename}), "\n");
		}
		else {
			wprint(box_ok(UNDERLINE $file_report->{filename}), "\n");
		}

		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		next unless $issueflag;

		# Cycle through all tags and print issues for each
		for my $tag (@TAGS){
			my @issues = @{$file_report->{$tag}} or next;

			# Print tag, line #, and issue
			wprint(box(BOLD BLUE $tag), "\n");

			for my $issue (@issues) {
				wprint(WHITE "  line $issue->{linenumber} - ", RESET, BOLD "$issue->{comment} ", RESET);

				# If valid API key
				# Check if issue has been closed on Github or Bitbucket, set to resolved
				wprint(box(BOLD GREEN "Resolved on GitHub"))
					if	$GITHUB->valid
					and	$GITHUB->closed_issues->{body} =~ m/$issue->{md5}/;

				wprint(box(BOLD GREEN "Resolved on Bitbucket"))
					if 	$BITBUCKET->valid
					and	$BITBUCKET->closed_issues =~ m/$issue->{md5}/;

				wprint("\n");
			}
			wprint("\n");
		}
	}

	printResults($_) for @{$entry->{dirs}};

	return 1;
}

#####################
# Repository Classes
#####################

BEGIN {
	package Watson::Repository;

	my %prototype = (
		valid	=> 0,
		username => undef,
		password	=> undef,
		repo	=> undef,
		open_issues => undef,
		closed_issues => undef,
	);
	my @other_fields = qw/access_token/;

	sub new {
		my ($class, %args) = @_;

		if ($class eq __PACKAGE__) {
			Carp::croak "This class is abstract and should not be instantiated";
		}

		my $self = {%prototype};
		for my $field (grep { exists $args{$_} } @other_fields, keys %prototype) {
			$self->{__PACKAGE__ . '/' . $field} = delete $args{$field};
		}

		if (keys %args) {
			Carp::croak "Unknown constructor arguments [@{[join ', ', keys %args]}]";
		}

		return bless $self => $class;
	}

	# a bit of meta-programming: writing the accessors
	for my $field (keys %prototype) {
		no strict 'refs';
		*{ $field } = sub {
			my $self = shift;
			return $self->{__PACKAGE__ . '/' . $field} = shift if @_;
			return $self->{__PACKAGE__ . '/' . $field};
		}
	}

	sub name { ... }

	sub authorization { ... }

	sub api  { shift->access_token(@_) }
	sub user { shift->username(@_)     }
	sub pw   { shift->password(@_)     }

	sub access_token {
		my $self = shift;
		return $self->{__PACKAGE__ . '/access_token'} = shift if @_;
		return $self->{__PACKAGE__ . '/access_token'};
	}
}

BEGIN {
	package Watson::Repository::GitHub;
	use parent -norequire, 'Watson::Repository';

	sub name { "GitHub" }
}

BEGIN {
	package Watson::Repository::Bitbucket;
	use parent -norequire, 'Watson::Repository';

	sub name { "Bitbucket" }
}

BEGIN {
	package Watson::UserAgent;

	my $instance;

	sub instance {
		my $self = shift;
		return $instance = shift if @_;
		require LWP::UserAgent;
		return $instance //= LWP::UserAgent->new;
	}

	sub post {
		my ($self, %headers) = @_;

		if (delete $headers{JSON} and my $data = delete $headers{Content}) {
			$headers{Content} = JSON::encode_json($data);
		}

		my $response = $self->instance->post(%headers);
		return bless $response => 'Watson::HTTP::Response';
	}

	sub get {
		my ($self, %headers) = @_;

		my $response = $self->instance->get(%headers);
		return bless $response => 'Watson::HTTP::Response';
	}
}

BEGIN {
	package Watson::HTTP::Response;
	use parent 'HTTP::Response';

	sub json {
		my $self = shift;
		my $utf8_encoded_content = Encode::encode('utf8', $self->decoded_content);
		return JSON::decode_json($utf8_encoded_content);
	}
}


###########################################################
# GitHub Setup
###########################################################

# Obtain API key for either Github
sub Watson::Repository::GitHub::setup {
	my $self = shift;

	say Watson::header();

	say Watson::box(BOLD GREEN "+"), BOLD "Obtaining OAuth Token for GitHub...\n", RESET;

	# Parse config to make sure no previous API exists
	Watson::parseConfig() if Watson::checkConfig();

	if (defined $self->api or defined $self->repo) {
		my $overwrite = uc Watson::prompt(
			{ default => "N" },
			Watson::box(BOLD RED "!"),
			BOLD "Previous GitHub API + Repo is in RC, are you sure you want to overwrite?\n", RESET,
			"      (Y)es/(N)o: ",
		);
		say "";

		if ($overwrite =~ /\A(?:NO?)?\z/){
			say Watson::box_error("Not overwriting current GitHub API + repo info");
			Watson::cExit(1);
		}
	}

	say for
		Watson::box_info("Access to your GitHub account required to make/update issues"),
		"      See help or README for more details on GitHub/Bitbucket access",
		"";

	# Get username, clear newlines surrounding text
	# If blank, give error
	$self->username(Watson::prompt(BOLD "Username: ", RESET, {
		default => sub {
			say Watson::box_error("Input blank. Please enter your username!");
			Watson::cExit(1);
		},
	}));

	$self->password(Watson::prompt(BOLD "Password: ", RESET, {
		echo => 0,
		default => sub {
			say Watson::box_error("Input blank. Please enter your password!");
			Watson::cExit(1);
		},
	}));

	# fetch an access token from GitHub
	$self->authorization;
	say RESET;

	# Get repo information
	# If blank, give error
	say for
		Watson::box_info(BOLD "Repo information required"),
		"      Please provide owner that repo is under followed by repo name",
		"      e.g. owner: nhmood, repo: watson (case sensitive)",
		"      See help or README for more details on GitHub access",
		"";

	my $owner = Watson::prompt(BOLD "Owner: ", RESET, {
		default => sub {
			say Watson::box_error("Input blank. Please enter the owner the repo is under!");
			Watson::cExit(1);
		},
	});
	my $repo = Watson::prompt(BOLD "Repo: ", RESET, {
		default => sub {
			say Watson::box_error("Input blank. Please enter the repo name!");
			Watson::cExit(1);
		},
	});
	$self->repo("$owner/$repo");

	$self->test_access;

	say Watson::box_error("Creating label for watson on GitHub...\n");
	$self->create_label("watson", "00AEEF");

	Configuration->replace_sections($RCNAME,
		github     => [$self->access_token],
		githubrepo => [$self->repo],
	);

	say for
		Watson::box_ok("GitHub successfully setup"),
		"      Issues will now automatically be updated on GitHub by default",
		"      See help or README for more details on GitHub/Bitbucket access",
		"";
	Watson::cExit(0);
}

sub Watson::Repository::GitHub::create_label {
	my ($self, $name, $color) = @_;

	my $response = Watson::UserAgent->post(
		sprintf('https://api.github.com/repos/%s/labels', $self->repo),
		Authorization => $self->authorization,
		JSON => 1,
		Content => {
			name => $name,
			color => $color,
		},
	);

	# Expected HTTP Status Code: "201 created";
	if ($response->code == 201) {
		say Watson::box_ok("Label successfully created");
	}
	elsif ($response->decoded_content =~ m/already_exists/i) {
		say Watson::box_info("Label already exists");
	}
	else {
		say Watson::box_error("Unable to access /repo/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]})");
		Watson::cExit(1);
	}
	say "";
}

sub Watson::Repository::GitHub::authorization {
	my $self = shift;

	return $self->{'Watson::Repository::GitHub/authorization'} //= do {
		my $basic_authorization = 'Basic ' . MIME::Base64::encode(
			$self->username . ":" . $self->password,
		);

		my $response = Watson::UserAgent->post(
			'https://api.github.com/authorizations',
			Authorization => $basic_authorization,
			JSON => 1,
			Content => {
				scopes   => ['repo'],
				note     => 'watson',
				note_url => 'http://watson.goosecode.com',
			},
		);

		# Expected Status Code: "201 Created"
		unless ($response->code == 201) {
			say box_error("Unable to obtain OAuth Token");
			cExit(1);
		}
		say box_ok("Obtained OAuth Token");

		my $dsc = $response->json;
		my $access_token = $dsc->{token};

		unless (defined $access_token) {
			Carp::croak "The returned JSON did not contain an access token.\n", Data::Dumper::Dump($dsc);
		}

		'token ' . $self->access_token($access_token);
	};
}



sub Watson::Repository::GitHub::test_access {
	my $self = shift;

	my $response = Watson::UserAgent->get(
		sprintf('https://api.github.com/repos/%s/issues', $self->repo),
		Authorization => $self->authorization,
	);

	unless ($response->is_success) {
		say box_error("Unable to access /repos/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]}).");
		cExit(1);
	}

	say box_ok("Repo successfully accessed");
	return 1;
}


###########################################################
# Github Issue Getter
###########################################################

sub Watson::Repository::GitHub::fetch_issues {
	my $self = shift;

	# Only attempt if API is specified
	unless (defined $self->access_token) {
		debugPrint("No GitHub access token, ignoring issue list\n");
		return;
	}

	debugPrint("Getting GitHub Issues\n");

	my $response = Watson::UserAgent->get(
		sprintf('https://api.github.com/repos/%s/issues?labels=watson&state=open', $self->repo),
		Authorization => $self->authorization,
	);

	unless ($response->is_success) {
		$self->valid(0);
		print box(BOLD RED "x");
		wprint("--> ", RESET);
		wprint(BOLD "Unable to access remote, GitHub API may be invalid\n");
		wprint(BOLD "          Consider running --remote (-r) option to regenerate key\n\n", RESET);
		return;
	}

	$self->valid(1);
	$self->open_issues($response->json);
	debugPrint(Data::Dumper::Dump($self->open_issues));

	$response = Watson::UserAgent->get(
		sprintf('https://api.github.com/repos/%s/issues?labels=watson&state=closed', $self->repo),
		Authorization => $self->authorization,
	);

	unless ($response->is_success) {
		say box_warn("Could not get closed issues, ignoring");
		return;
	}

	$self->closed_issues($response->json);
	debugPrint(Data::Dumper::Dump($self->closed_issues));
}


###########################################################
# Github Issue Poster
###########################################################

sub Watson::Repository::GitHub::post_issue {
	my ($self, $issue) = @_;
	# If Github API has been registered, post on Github
	return unless defined $self->access_token;

	# Check if md5 of issue has already been posted
	# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
	return if $self->open_issues->{body}   =~ m/$issue->{md5}/;
	return if $self->closed_issues->{body} =~ m/$issue->{md5}/;

	# Format title and body for creating issue
	# Title format: comment [basename of file], escape any '
	(my $file = $issue->{file}) =~ s{^.+/}{};
	my $title = "$issue->{comment} [$file]";
	# [fixme] - Figure out how to escape ' character on JSON post
	$title =~ s/'//;

	debugPrint("Formatted title for GitHub Post : $title\n");

	# Format comment to escape any ' so JSON will be formatted properly
	my $response = Watson::UserAgent->post(
		sprintf('https://api.github.com/repos/%s/issues', $self->repo),
		Authorization => $self->authorization,
		JSON => 1,
		Content => {
			title => $title,
			body => join("\n" =>
				"__filename__ : $issue->{file}",
				"__line #__ :   $issue->{linenumber}",
				"__tag__ :      $issue->{tag}",
				"__md5__ :      $issue->{md5}",
			),
		},
	);
}


###########################################################
# Bitbucket Setup
###########################################################

# Set up Bitbucket access
# [todo] - Only basic http auth, get OAuth for Bitbucket
# Bitbucket OAuth needs to redirect to some grant access page
# Not sure how to do that with a CLI, basic HTTP auth for now

sub Watson::Repository::Bitbucket::setup {
	my $self = shift;

	# Set remote setup to one so password isn't asked for in Bitbucket parseConfig section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	say Watson::header();

	say Watson::box(BOLD GREEN "+"), BOLD "Attempting to access Bitbucket...", RESET;

	# Parse config to make sure no previous API exists
	Watson::parseConfig() if Watson::checkConfig();

	if (defined $self->access_token or defined $self->repo) {
		my $overwrite = uc Watson::prompt(
			{ default => 'N' },
			Watson::box(BOLD RED "!"),
			BOLD "Previous Bitbucket Repo is in RC, are you sure you want to overwrite?\n", RESET,
			"      (Y)es/(N)o: "
		);
		say "";

		if ($overwrite =~ /\A(?:NO?)?\z/) {
			say Watson::box_error("Not overwriting current Bitbucket repo info");
			Watson::cExit(1);
		}
	}

	say for
		box_info("Access to your Bitbucket account required to make/update issues"),
		"      See help or README for more details on GitHub/Bitbucket access",
		"",
		join(box(BOLD RED "!"), BOLD "Bitbucket OAuth not implemented yet.", RESET),
		"      Basic HTTP Auth in use, will request PW entry every time.",
		"";

	my $username = Watson::prompt(BOLD "Username: ", RESET, {
		default => sub {
			say Watson::box_error("Input blank. Please enter your username!");
			Watson::cExit(1);
		},
	});
	$self->username($username);
	$self->access_token($username);

	my $password = Watson::prompt(BOLD "Password: ", RESET, {
		echo => 0,
		default => sub {
			say Watson::box_error("Input blank. Please enter your password!");
			Watson::cExit(1);
		},
	});
	$self->password($password);

	# Get repo information
	# If blank, give error
	say for
		Watson::box_info("Repo information required"),
		"      Please provide owner that repo is under followed by repo name",
		"      e.g. owner: nhmood, repo: watson (case sensitive)",
		"      See help or README for more details on GitHub access",
		"";


	my $owner = Watson::prompt(BOLD "Owner: ", RESET, {
		default => sub {
			say Watson::box_error("Input blank. Please enter the owner the repo is under!");
			Watson::cExit(1);
		},
	});
	my $repo = Watson::prompt(BOLD "Repo: ", RESET, {
		default => sub {
			say Watson::box_error("Input blank. Please enter the repo name!");
			Watson::cExit(1);
		},
	});
	say "";
	$self->repo("$owner/$repo");

	$self->test_access;
	say "";

	Configuration->replace_sections($RCNAME,
		bitbucket     => [$self->access_token],
		bitbucketrepo => [$self->repo],
	);

	say for
		Watson::box_ok("Bitbucket successfully setup"),
		"      Issues will now automatically be updated on Bitbucket by default",
		"      Use -l, --local to not update against GitHub",
		"      See help or README for more details on GitHub/Bitbucket access",
		"";

	Watson::cExit(0);
}

sub Watson::Repository::Bitbucket::authorization {
	my $self = shift;
	return $self->{'Watson::Repository::Bitbucket/authorization'} //= do {
		'Basic ' . MIME::Base64::encode($self->username . ":" . $self->password);
	};
}

sub Watson::Repository::Bitbucket::test_access {
	my $self = shift;

	my $response = Watson::UserAgent->get(
		sprintf('https://bitbucket.org/api/1.0/repositories/%s', $self->repo),
		Authorization => $self->authorization,
	);

	unless ($response->is_success) {
		say Watson::box_error("Unable to access remote repo with given credentials."),
		say BOLD "Check that credentials are correct and repository exists under owner", RESET;
		Watson::cExit(1);
	}

	say Watson::box_ok("Successfully accessed remote repo with given credentials");
	return 1;
}

###########################################################
# Bitbucket Issue Getter
###########################################################

sub Watson::Repository::Bitbucket::fetch_issues {
	my $self = shift;

	# Only attempt if repo is specified
	unless (defined $self->repo) {
		Watson::debugPrint("No Bitbucket Repo, ignoring issue list\n");
		return;
	}

	Watson::debugPrint("Getting Bitbucket Issues\n");

	# password is already known from setup.


	# Get all issues, Bitbucket differentiates between open/new so we can just look for all
	# The open issue var is used only for preventing posting again anyways
	# Only need closed ones to update final output, might change in Github too?
	my $response = Watson::UserAgent->get(
		sprintf('https://bitbucket.org/api/1.0/repositories/%s/issues', $self->repo),
		Authorization => $self->authorization,
	);
	unless ($response->is_success) {
		$self->valid(0);
		print Watson::box(BOLD RED "x");
		Watson::wprint("--> ", RESET);
		Watson::wprint(BOLD "Unable to access remote, Bitbucket settings may be invalid\n");
		Watson::wprint(BOLD "          Consider running --remote (-r) option to regenerate settings\n\n", RESET);
		return;
	}

	$self->open_issues($response->decoded_content);
	$self->valid(1);

	$response = Watson::UserAgent->get(
		sprintf('https://bitbucket.org/api/1.0/repositories/%s/issues?status=resolved', $self->repo),
		Authorization => $self->authorization,
	);

	unless ($response->is_success) {
		# [todo] - better error handling
		return;
	}

	$self->closed_issues($response->decoded_content);
	Watson::debugPrint($self->closed_issues);

	debugPrint($BITBUCKET->open_issues);
}


###########################################################
# Bitbucket Issue Poster
###########################################################

# Post issues to github/bitbucket
sub postBitbucket {
	$BITBUCKET->post_issue(@_);
}

sub Watson::Repository::Bitbucket::post_issue {
	my ($self, $issue) = @_;

	return unless defined $self->access_token;

	# Check if md5 of issue has already been posted
	# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
	return if $self->open_issues   =~ m/$issue->{md5}/;
	return if $self->closed_issues =~ m/$issue->{md5}/;

	# Format title and body for creating issue
	# Title format: comment [basename of file], escape any '
	(my $filename = $issue->{file}) =~ s{\A.+/}{};

	# [todo] - figure out it the formatting actually works as expected
	my $response = Watson::UserAgent->post(
		sprintf('https://bitbucket.org/api/1.0/repositories/%s/issues', $self->repo),
		Authorization => $self->authorization,
		Content => {
			title => "$issue->{comment} [$filename]",
			content => join("\n",
				"__filename__ : $issue->{file}",
				"__line #__ :   $issue->{linenumber}",
				"__tag__ :      $issue->{tag}",
				"__md5__ :      $issue->{md5}",
			),
		},
	);

	unless ($response->is_success) {
		# [todo] - better error handling
		return;
	}

	Watson::debugPrint($response->decoded_content);
}


##########################
# Box glyph, e.g [!], [x]
##########################

sub box { join '', BOLD, "[ ", RESET, @_, RESET, BOLD, " ] ", RESET }

# often-used combinations:
sub box_ok    { join '', box(BOLD GREEN   "o"), BOLD @_, RESET }
sub box_info  { join '', box(BOLD YELLOW  "!"), BOLD @_, RESET }
sub box_warn  { join '', box(BOLD MAGENTA "!"), BOLD @_, RESET }
sub box_error { join '', box(BOLD RED     "x"), BOLD @_, RESET }

#########
# prompt
#########

sub prompt {
	my %config = (
		out => select(),
		in	=> \*STDIN,
		echo => 1,
		('HASH' eq ref $_[0])  ? %{ shift @_ } :
		('HASH' eq ref $_[-1]) ? %{ pop   @_ } :
		(),
	);

	my $oldfh = select $config{out};
	$| = 1;  # no buffering
	print @_;
	system 'stty', '-echo' unless $config{echo};
	chomp(my $answer = readline $config{in});
	system 'stty', 'echo'  unless $config{echo};
	select $oldfh;
	if (exists $config{default} and not length $answer) {
		return $config{default}->() if ref $config{default} eq 'CODE';
		return $config{default};
	}
	return $config{default} if exists $config{default} and not length $answer;
	return $answer;
}

# kate: space-indent off; indent-width 4; mixedindent off; indent-mode cstyle;
