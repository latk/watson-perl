#!/usr/bin/env perl
# watson - inline issue manager
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# This content is licensed under the MIT License
# See the file LICENSE for copying permission

use strict;
use warnings;
use feature qw< say state >;  # implies dependency on perl 5.010
use autodie; # in Core since 5.010
use utf8;  # in Core since 5.006 -- define encoding of source code

package App::Watson;
use version; our $VERSION = qv("1.003_001"); # PAUSE hack

our $COPYRIGHT = '2012-2013 goosecode labs';
our $PROJECT_HOMEPAGE = 'http://goosecode.com/projects/watson';
our $ISSUE_TRACKER    = 'https://github.com/nhmood/watson-perl/issues';

# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - wrap printed lines around 80 characters
# [todo] - command line option to remove remote repos
# [todo] - replace json parser with just grep? need to get status if failed
# [todo] - add ability to update issue if same title but different md5
# [todo] - implement local only reporting (make it default?)
# [todo] - progress bar for obtaining github/bitbucket issue list
# [todo] - local should be default, must use -r or remote flag to post and check?
#        - maybe have it check against background unless -local is passed
#        - but dont post unless --post is used (make it faster?)
# [todo] - add status indicator for remote requests
#        - we know # of requests and which we are on, can do it that way
# [todo] - change github issue checks to -d instead of issue?key=val
# [todo] - add remote / local options and necessary logic
# [todo] - replace open/closed issue var with just all and closed?
# [todo] - implement column wrapping with Text::Wrap

###########################################################
# Global parameters
###########################################################

local $SIG{INT} = sub {
    print "\n";
    exit 1;
};

use Term::ANSIColor qw< :constants >;     # in Core since 5.006
use Data::Dumper    qw<>;                 # in Core since 5.005
use Digest::MD5     qw<>;                 # in Core since 5.007.003
use File::Copy      qw<>;                 # in Core since 5.002
use MIME::Base64    qw<>;                 # in Core since 5.007.003
use Carp            qw<>;                 # in Core since 5.000
use Encode          qw<>;                 # in Core since 5.007.003
use IO::Handle      qw<>;                 # in Core since 5.003.007
use Cwd             qw<>;                 # in Core since 5.000
use English         qw< -no_match_vars >; # in Core since 5
use Hash::Util      qw< lock_keys >;      # in Core since 5.008
use FindBin         qw<>;                 # in Core since 5.003.007
use lib "$FindBin::RealBin/lib";       # in Core since 5.001
use JSON::PP        qw<>;                 # in Core since 5.013.009
# use LWP::UserAgent; -- loaded on demand

use App::Watson::UI         qw<>;
use App::Watson::Issue      qw<>;
use App::Watson::IssueList  qw<>;
use App::Watson::Repository qw<>;
use App::Watson::UserAgent  qw<>;

# App Config
our $DEBUG  = $ENV{WATSON_DEBUG};
our $RCNAME = ".watsonrc";  # Change config file name

# Global variables
our @DIRS;
our @FILES;
our @TAGS;
our @IGNORE;
our $REMOTESETUP = 0;
our $MAX_DEPTH = 0;
lock_keys(our %IGNORE_RC, qw< dirs files tags ignore >);

our $GITHUB    = App::Watson::Repository::GitHub->new;
our $BITBUCKET = App::Watson::Repository::Bitbucket->new;

our %REPOSITORIES = (
    github    => $GITHUB,
    bitbucket => $BITBUCKET,
);

exit main(@ARGV) unless caller; # only execute if called directly

sub main {
    my @args = @_;

    App::Watson::CommandLine::parse(@args);
    check_config();
    parse_config();
    my @issue_tree = start_scan(\@FILES, \@DIRS);
    create_report(\@TAGS, @issue_tree);
    return 0;
}

###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debug_print {
    my @strings = @_;
    return print @strings if $DEBUG;
    return;
}

###########################################################
# Directory checker
###########################################################

# check_dir - checks if directory can be opened
# Different from just using -d, checks if able to OPEN
sub check_dir {
    my ($dir) = @_;

    # Error check for input
    if (not length $dir) {
        print("No directories specified.\n");
        return 0;
    }

    # Check if directory can be opened
    opendir my $tDIR, $dir or do {
        print(qq{Cannot open dir "$dir": $!\n});
        return 0;
    };

    closedir $tDIR;
    debug_print(qq{"$dir" exists and opened successfully.\n});
    return 1;
}

###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub check_config {
    # Should have individual .rc for each dir that watson is in
    # This allows you to keep different preferences for different projects

    # Check for rc
    debug_print("[Checking for $RCNAME]\n");
    if (-e $RCNAME) {
        debug_print("$RCNAME found\n\n");
        return 1;
    }
    else {
        debug_print("$RCNAME not found!\n");
        debug_print("Creating default $RCNAME\n");

        # Create default rc
        create_rc($RCNAME);
        return 0;
    }
}


###########################################################
# Default config file writer
###########################################################

# Create default RC file with some generic settings
sub create_rc {
    my ($file_name) = @_;

# [fixme] - Figure out a way to indent this?
my $rcdefault = <<'EOF';
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories
[dirs]
./

# Tags
[tags]
fix
fixme
review
reviewme
todo

# Ignores
[ignore]
.git
*.swp
*.class
*.jar
*.zip
*.apk
*.png
*.jpg
*.gif
*.gz
*.dex
*.so
EOF

    debug_print($rcdefault);

    # Print default rc above to specified file
    open my $file, "+>>", $file_name;
    my $success = print { $file } $rcdefault;
    close $file;

    return $success;
}

BEGIN {
    package App::Watson::CommandLine;
    use Term::ANSIColor qw< :constants >;
    use English qw< -no_match_vars >;

    my @options = (
        {
            flag    => [qw< -d --dirs >],
            action  => \&dirs,
            doc     => 'list of directories to search in',
            arg     => '<dir>...'
        },
        {
            flag    => [qw< -f --files >],
            action  => \&files,
            doc     => 'list of files to search in',
            arg     => '<file>...'
        },
        {
            flag    => [qw< -h --help >],
            action  => \&help,
            doc     => 'output the help message',
        },
        {
            flag    => [qw< -i --ignore >],
            action  => \&ignore,
            doc     => 'list of files, directories, or types to ignore',
            arg     => '<pattern>...',
        },
        {
            flag    => [qw< -p --parse-depth >],
            action  => \&parse_depth,
            doc     => 'depth to recursively parse directories',
        },
        {
            flag    => [qw< -r --remote >],
            action  => \&remote,
            doc     => 'list / create tokens for Bitbucket/Github',
        },
        {
            flag    => [qw< -t --tags >],
            action  => \&tags,
            doc     => 'list of tags to search for',
            arg     => '<tag>...'
        },
        {
            flag    => [qw< -v --version >],
            action  => \&version,
            doc     => 'say watson version and info',
        },
    );

    sub parse {
        my @args = @_;
        App::Watson::debug_print("[Checking CL args]\n");
        App::Watson::debug_print("Total args: ", $#args + 1, "\n");

        my %flag_actions;
        for my $option (@options) {
            $flag_actions{$_} = $option->{action} for @{ $option->{flag} };
        }

        if (not @args) {
            App::Watson::debug_print("No command line arguments passed.\n\n");
            return;
        }

        while (@args) {
            my $item = shift @args;
            App::Watson::debug_print("Main Item: $item\n");

            my $action = $flag_actions{$item}
                or die qq{Can't understand command line argument "$item"};
            $action->(\@args, \%flag_actions);
        }

        return 1;
    }

    sub slurp_items {
        my ($args, $opts, $cb) = @_;

        my @results;

        # Keep checking following options until another flag or end
        while (@$args) {
            # stop when the current item is a known flag
            last if exists $opts->{$args->[0]};

            my $item = shift @$args;
            push @results, $cb->($item);
        }

        return @results;
    }

    sub help {
        App::Watson::debug_print("Help flag passed\n");

        # go through all options and pre-format them
        my @commands;
        for my $option (@options) {
            my ($flags, $arg, $docs) = @$option{qw< flag arg doc >};
            my $flag_description = sprintf q(  {%s}), join q(|) => @$flags;
            $flag_description .= qq( $arg) if defined $arg;

            push @commands, [$flag_description, $docs];
        }

        say for
            BOLD . "Usage: $PROGRAM_NAME [OPTIONS...]" . RESET,
            q(),
            'Running watson with no arguments will take settings from the RC file. If no RC file exists, a default RC file will be created.',
            q(),
            App::Watson::UI->display_kv(@commands),
            'Any number of files, tags, dirs, and ignores can be listed after each flag. Ignored files should be space separated. To use "*.filetype" identifier, enclose in "" to avoid shell substitutions',
            q(),
            App::Watson::UI->details(
            ['Report bugs to'    => "<$App::Watson::ISSUE_TRACKER>"],
            ['Watson home page'  => "<$App::Watson::PROJECT_HOMEPAGE>"],
            ['Copyright'         => "(c) $App::Watson::COPYRIGHT"],
        );

        exit 0;
    }

    sub version {
        App::Watson::debug_print("Version flag passed\n");

        say for
            "watson $App::Watson::VERSION UNSTABLE",
            "Copyright (c) $App::Watson::COPYRIGHT",
            "Licensed under MIT, see LICENSE for details",
            q(),
            "Written by nhmood, see <$App::Watson::PROJECT_HOMEPAGE>";

        exit 0;
    }

    sub parse_depth {
        my ($args, $opts) = @_;
        App::Watson::debug_print("Parse Depth flag passed\n");
        # Check to make sure next param is a valid number (non-negative)

        if (not @$args) {
            say App::Watson::UI->warning('--parse-depth requires a numeric argument!');
            return;
        }

        my $depth = shift @$args;

        if ($depth =~ /[^0-9]/) {
            say App::Watson::UI->warning('--parse-depth requires a numeric argument');
            return;
        }

        # [reviewme] - should this be $depth + 1 instead?
        $MAX_DEPTH = $depth;
        App::Watson::debug_print("Valid parse depth: $MAX_DEPTH\n");

        return;
    }

    sub remote {
        my ($args, $opts) = @_;
        App::Watson::debug_print("Remote Flag passed\n");

        # When generating OAuth Token for github/bitbucket
        # no other params should be passed
        if (@$args > 1) {
            App::Watson::debug_print("Not the only flag, exiting\n");
            say App::Watson::UI->error(
                '--remote requires a singe argument',
                'Please run the remote flag alone to generate the GitHub or Bitbucket OAuth token. See help for more details',
            );
            exit 1;
        }

        if (@$args) {
            my $service = lc shift @$args;

            if (my $repo = $REPOSITORIES{$service}) {
                $repo->setup;
                exit 0;
            }

            say App::Watson::UI->error(
                qq(Unknown service "$service".),
                'Run "watson --remote {github|bitbucket}" to add a remote.',
                'That\'s all we support right now :(',
                'See help for more details.',
            );
            exit 1;
        }

        App::Watson::parse_config() if App::Watson::check_config();

        if (not defined $BITBUCKET->access_token and not defined $GITHUB->access_token) {
            say App::Watson::UI->error(
                'No remotes currently exist!',
                'Run "watson --remote {github|bitbucket}" to add a remote.',
                'That\'s all we support right now :(',
                'See help for more details',
            );
            exit 1;
        }

        for my $service (grep { defined $_->access_token } %REPOSITORIES) {
            my $name = $service->name;
            say App::Watson::UI->success(
                $name,
                App::Watson::UI->details(
                    ["$name User"   => $service->username],
                    ["$name Repo"   => $service->repo],
                ),
            );
        }

        exit 0;
    }

    sub dirs {
        my ($args, $opts) = @_;
        App::Watson::debug_print("Dir flag passed\n");
        return slurp_items($args, $opts => sub {
            my ($dir) = @_;
            App::Watson::debug_print("Dir Index: $dir\n");

            if (App::Watson::check_dir($dir)) {
                App::Watson::debug_print("dirflag: {$dir} valid directory, added from CL.\n");

                # If we ever get into this, means CL passed
                # Set RC ignore so we don't look at rc
                App::Watson::debug_print("Ignoring RC Files/Dirs\n\n");
                $IGNORE_RC{dirs} = 1;

                # Remove trailing slashes
                $dir =~ s{/+\z}{};
                push @DIRS, $dir;
            }
        });
    }

    sub files {
        my ($args, $opts) = @_;
        App::Watson::debug_print("File flag passed\n");
        return slurp_items($args, $opts => sub {
            my ($file) = @_;
            App::Watson::debug_print("File Index: $file\n");

            if (not -f $file) {
                say App::Watson::UI->error(
                    qq(The path "$file" does not seem to point to a valid file.)
                );
                exit 1;
            }

            App::Watson::debug_print("fileflag: {$file} valid file, added from CL.\n");

            # If we ever get into this, means CL passed
            # Set RC ignore so we don't look at rc
            App::Watson::debug_print("Ignoring RC Files/Dirs\n\n");
            $IGNORE_RC{files} = 1;

            push @FILES, $file;
        });
    }

    sub tags {
        my ($args, $opts) = @_;
        App::Watson::debug_print("Tag flag passed\n");
        return slurp_items($args, $opts => sub {
            my ($tag) = @_;
            App::Watson::debug_print("Tag Index: $tag\n");
            App::Watson::debug_print("tagflag: {$tag} added from CL.\n");

            # If we ever get into this, means CL passed
            # Set RC ignore so we don't look at rc
            App::Watson::debug_print("Ignoring RC tags\n\n");
            $IGNORE_RC{tags} = 1;

            push @TAGS, $tag;
        });
    }

    sub ignore {
        my ($args, $opts) = @_;
        App::Watson::debug_print("Tag flag passed\n");
        return slurp_items($args, $opts => sub {
            my ($ignoreflag) = @_;
            App::Watson::debug_print("Ignore Index: $ignoreflag\n");
            App::Watson::debug_print("ignoreflag: {$ignoreflag} added from CL.\n");

            # If we ever get into this, means CL passed
            # Set RC ignore so we don't look at rc
            App::Watson::debug_print("Ignoring RC ignore\n\n");
            $IGNORE_RC{ignore} = 1;

            push @IGNORE, $ignoreflag;
        });
    }
}


###########################################################
# Config file parser
###########################################################

BEGIN {
    package App::Watson::Configuration;
    use English qw< -no_match_vars >;

    sub new_from_file {
        my ($class, $filename) = @_;

        my %sections;

        my $section;
        open my $rc, "<", $filename;
        while (<$rc>) {
            chomp;
            App::Watson::debug_print("# line $INPUT_LINE_NUMBER: $_\n");

            next if !/\S/;    # Skip empty lines
            next if /\A\s*#/; # Ignore full line comments

            # Regex to fond [section], then store into $section
            if (/\A \[( \w+ )\] \s*\z/x) {
                $section = lc $1;
                App::Watson::debug_print("# recognized as section [$section]\n");
                next;
            }

            die qq/No section specified at "$filename" line $INPUT_LINE_NUMBER./
                unless defined $section;

            push @{ $sections{$section} }, $_;
            App::Watson::debug_print("# added to [$section]\n");
        }
        close $rc;

        return bless {
            sections => \%sections,
        } => $class;
    }

    sub sections {
        my ($self) = @_;
        return $self->{sections};
    }

    sub section {
        my ($self, @other_args) = @_;
        Carp::croak qq/Argument "name" is required/ unless @other_args;
        my $name = shift @other_args;
        Carp::croak "name must be defined" unless defined $name;
        return $self->{sections}{$name} if exists $self->{sections}{$name};
        return my $default = shift @other_args if @other_args;
        Carp::croak qq/No entry for "$name" present, and no default given/;
    }

    sub section_names {
        my ($self) = @_;
        return keys %{ $self->{sections} };
    }

    sub replace_sections {
        my (undef, $filename, %replacements) = @_;

        # First, delete the old sections if applicable:

        my $nlc = 0;
        if (App::Watson::check_config()){
            my $section = q();
            open my $in,  "<", $filename;
            open my $out, ">", "$filename.new";
            while (<$in>){
                chomp;
                $section = lc $1 if /^\[(\w+)\]/;

                # Max 2 consecutive empty lines
                if (not /\S/) {
                    $nlc++;
                    if ($nlc <= 2) {
                        say { $out } q();
                        next;
                    }
                }

                next if exists $replacements{$section};

                # This section won't be changed - copy everything over.
                say { $out } $_;
                $nlc = 0;  # Reset newline count
            }
            close $in;
            close $out;

            # Remove old RC file and replace with new one
            File::Copy::move("$filename.new" => $filename)
                or die qq{Can't move update RC at "$filename": $!};
        }

        # Now, append the new sections to the file (new or old, doesn't matter)

        open my $file, ">>", $filename;

        for my $section (sort keys %replacements) {
            # print remaining newlines
            say { $file } q() for $nlc .. 1;

            say { $file } "[$section]";
            say { $file } $_ for @{ $replacements{$section} };

            $nlc = 0;
        }

        close $file;

        return;
    }

    my %actions = (
        dirs        => \&handle_dirs,
        tags        => \&handle_tags,
        ignore      => \&handle_ignore,
        github      => \&handle_service,
        githubrepo  => \&handle_repo,
        bitbucket   => \&handle_service,
        bitbucketrepo=>\&handle_repo,
    );

    sub parse {
        my ($self) = @_;

        # Add . and .. and .git to ignorelist
        push @IGNORE, qw< . .. *.swp .watsonrc >;

        for my $section ($self->section_names) {
            my $action = $actions{$section} or die qq/Unknown section "$section"/;
            my @lines = @{ $self->section($section) };

            App::Watson::debug_print("[$section] contains [@lines]\n");

            $action->($section => $_) for @lines;
        }

        return 1;
    }

    # If @DIRS or @FILES wasn't populated by CL args, populate from rc
    sub handle_dirs {
        my ($name, @lines) = @_;
        if ($IGNORE_RC{dirs} or $IGNORE_RC{files}) {
            App::Watson::debug_print("Directories set from command line, ignoring rc [dirs]!\n");
            return;
        }

        for my $line (@lines) {
            # Regex for dirs, then push to @DIRS
            $line =~ m{\A\s* ((?:[.]?/?\w?+/?)+) \s*\z}x
                or die qq{The line "$line" in a "dirs" section did not contain a valid path};
            (my $dir = $1) =~ s{/+\z}{};
            App::Watson::debug_print("dirs: $dir added from rc. \n");
            push @DIRS, $dir;
        }

        return;
    }

    # If @TAGS wasn't populated by CL args, populate from rc
    sub handle_tags {
        my ($name, @lines) = @_;
        if ($IGNORE_RC{tags}) {
            App::Watson::debug_print("Directories set from command line, ignoring rc [dirs]!\n");
            return;
        }

        for my $line (@lines) {
            # Regex for tags, then push to @TAGS
            $line =~ /^\A\s* (\w+(?: [|] [0-9] )?) \s* (?: \#*.* )? \z/x
                or die qq{The line "$line" in a "tags" section did not contain a valid tag};
            my $tag = $1;
            App::Watson::debug_print("tags: $tag added from rc.\n");
            push @TAGS, $tag;
        }

        return;
    }

    # If @IGNORE wasn't populated by CL args, populate from rc
    sub handle_ignore {
        my ($name, @lines) = @_;
        if ($IGNORE_RC{ignore}) {
            App::Watson::debug_print("Directories set from command line, ignoring rc [dirs]!\n");
            return;
        }

        for my $line (@lines) {
            # Regex for dirs to ignore, then push to @IGNOREDIR
            $line =~ m{\A\s* (.+) \s*\z}x
                or die qq{The line "$line" in a "ignore" section did not contain a valid path};
            (my $path = $1) =~ s{(/)+\z}{}; # remove trailing slashes
            App::Watson::debug_print("ignore: $path added from rc.\n");
            push @IGNORE, $path;
        }

        return;
    }

    sub handle_service {
        my ($name, @lines) = @_;
        my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

        for my $api (@lines) {
            say App::Watson::UI->warn(["The ", $repository->name, " API was already set, overwriting"])
                if defined $repository->access_token;

            # No need for regex on API key
            App::Watson::debug_print($repository->name . "API: $api\n");
            $repository->access_token($api);
        }

        return;
    }

    sub handle_repo {
        my ($name, @lines) = @_;
        $name =~ s/repo\z//;
        my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

        for my $repo (@lines) {
            say App::Watson::UI->warn(["The ", $repository->name, " Repo was already set, overwriting"])
                if defined $repository->repo;

            # No need for regex on repo
            App::Watson::debug_print($repository->name . "Repo: $repo\n");
            $repository->repo($repo);
        }

        # If setting up remote, don't ask for password / do any remote stuff
        # Won't need this when OAuth implemented but it does optimize the code...

        # Get list of issues, also checks if API key is valid
        $repository->fetch_issues unless $REMOTESETUP;
    }
}

# Go through config file and determine dirs, tags, and ignores to use
sub parse_config {
    # Parse rc
    debug_print("Parsing $RCNAME\n");

    return App::Watson::Configuration->new_from_file($RCNAME)->parse;
}


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub start_scan {
    my ($files, $directories) = @_;

    my @files_with_issues;

    # If files passed to command line, push those to structure
    # Have to populate structure this way to print properly
    if ($IGNORE_RC{files}) {
        # For each file obtained from CL (if any) parse file
        # Create proper structure for files so we can push to @STRUCTURE
        push @files_with_issues, {
            files => [ map { parse_file($_) } @$files ],
        };
    }

    # For each directory obtained from rc or CL, look for files in them
    # This will always be valid, not condition like files above
    push @files_with_issues, map { parse_directories($_) } @$directories;

    print("\n");
    return @files_with_issues;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parse_directories {
    my ($dir, $depth) = @_;
    $depth //= 1;
    return if $MAX_DEPTH and $depth > $MAX_DEPTH;
    debug_print("parse_directories: |$dir| at depth $depth/$MAX_DEPTH\n");
    return unless check_dir($dir); # Error check for input

    my @pdirs;   # subdirectories found
    my @pfiles;  # files found

    # Loop through all entries in directory
    debug_print(qq{Looping through all files/folders in "$dir"\n});

    # Open dir and get list of all files
    opendir my($wd), $dir;
    ENTRY: for my $entry (sort grep { not /\A [.][.]? \z/x } readdir $wd) {
        # Combine dir and entry to make full path
        my $path = "$dir/$entry";

        debug_print("path: |$path|\n");

        # Make sure it isn't part of ignored list
        # If it is, set to "", won't pass dir/file check
        # [reviewme] - Should we warn users when file is ignored on stdout?
        for my $ignore (@IGNORE){
            # Check for any *.type in ignore list (list .swp)
            # Regex to see if extension is .type, ignore if so
            if (not ref $ignore) {
                ($ignore) =
                    map  { qr/\A$_\z/ }
                    join q(.*) =>
                    map  { quotemeta $_ }
                    split /[*]/, $ignore;
            }
            if ($entry =~ /$ignore/) {
                debug_print("|$path| is on the ignore list, skipping\n");
                next ENTRY;
            }
        }

        # Check if entry is a file, if so parse
        if (-f $path) {
            debug_print("|$path| is a file!\n");
            push @pfiles, parse_file($path);
        }
        # Check if entry is dir, if so parse
        elsif (-d $path) {
            debug_print("|$path| is a dir!\n");
            push @pdirs, parse_directories($path, $depth + 1);
        }

        # Add directory to ignore list so it isn't repeated again
        push @IGNORE, $path;
    }

    closedir $wd;
    # Create has to hold all parsed files and folders
    return {
        files => \@pfiles,
        dirs => \@pdirs,
    };
}


###########################################################
# File Parser
###########################################################

sub parse_file {
    # [fixme] - need a better check for valid files (when using @_)
    my ($file) = @_;
    debug_print("parse_file: |$file|\n");

    # Return unless the input is a text file
    return unless ( -T $file );

    # Get filetype and set corresponding comment type
    my $comment_regex = comment_regex($file);

    my %issue_list = (
        filename => $file,
        (map { $_ => [] } @TAGS),
    );

    # Read source file line by line
    open my $wf, "<", $file;
    while (<$wf>) {
        next unless /$comment_regex/x;
        my ($ftag, $fissue) = ($1, $2);
        App::Watson::debug_print(
            "Issue found!\n",
            "Tag: $ftag\n",
            "Issue: $fissue\n",
        );

        next unless exists $issue_list{$ftag};

        my $issue = App::Watson::Issue->new(
            path    => $file,
            line    => $INPUT_LINE_NUMBER,
            comment => $fissue,
            tag     => $ftag,
        );

        push @{ $issue_list{$ftag} }, $issue;

        $issue->post;
    }
    close $wf;

    return \%issue_list;
}


###########################################################
# Comment setter
###########################################################

sub comment_regex {
    my ($file) = @_;

    state $watson_comment = qr/\s* \[(\S+)\] \s*[-]\s* (.+?) \s*/x;
    state $c_comment   = qr{(?<=[/][*]) $watson_comment (?=\z | [*][/])}x;
    state $cpp_comment = qr{(?<=[/][/]) $watson_comment    \z          }x;
    state $d_comment   = qr{(?<=[/][+]) $watson_comment (?=\z | [+][/])}x;
    state $sh_comment  = qr{(?<=[\#])   $watson_comment    \z          }x;
    state $sql_comment = qr{(?<=[-][-]) $watson_comment    \z          }x;
    state $ml_comment  = qr{(?=[(][*])  $watson_comment (?=\z | [*][)])}x;
    state $lisp_comment= qr{(?<=[;])    $watson_comment    \z          }x;
    state $sgml_comment= qr{(?<= <!--)  $watson_comment (?=\z | -->)   }x;
    state $tex_comment = qr{(?<=[%])    $watson_comment    \z          }x;
    state $haskell_comment =
                         qr{(?=[{][-])  $watson_comment (?=\z | [-][}])}x;
    state $fortran_comment =
                         qr{(?<=^[C!])  $watson_comment    \z          }xm;

    state $comment = do {

        # comments by their file endings. Each entry is a regex object
        #   that matches the whole comment.
        # Only single line comments are supported, this is a feature, not a bug.
        # [todo] - document this feature.
        my @comment_associations = (
            [$lisp_comment,     qw< asm lisp clj scm ss >],
            [$tex_comment,      qw< tex erl ps >],
            [$sgml_comment,     qw< htm html xml >],
            [$fortran_comment,  qw< f f90 f95 f03 >],
            [$ml_comment,       qw< ml >],
            [$sql_comment,      qw< sql lua e >],
            [$c_comment,        qw< css >],
            [$cpp_comment,      qw< sass scss >],
            [qr/$sql_comment | $haskell_comment/x,         qw< hs >],
            [qr/$cpp_comment | $c_comment | $sh_comment/x, qw< php >],
            [qr/$cpp_comment | $c_comment | $d_comment/x,  qw< d >],
            [qr/$cpp_comment | $c_comment/x,
                qw< cpp cc c h c++ m mm java class cs js go scala >],
            [$sh_comment,
                qw< sh zsh bash rb pl pm py coffee t csf r >],
        );

        # index the comment regexes by extension
        my %comment;
        for my $association (@comment_associations) {
            my ($regex, @exts) = @$association;
            $comment{$_} = $regex for @exts;
        }
        \%comment;
    };

    # split the filename into it's various extensions
    my (undef, @extensions) =  split /[.]/, $file;

    # weigh the last extension highest
    # If unrecognized, try to grab next .something extension
    # This is to account for file.cpp.1 or file.cpp.bak, ect
    # Ignore “extensions” with spaces in them: probably false positives
    for (grep { not /\s/ } reverse @extensions) {
        return $comment->{lc $_} // next;
    }

    say App::Watson::UI->warning("Could not determine filetype for $file, using # as comment");
    return $sh_comment;
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub create_report {
    my ($tags, @entries) = @_;

    my $pwd  = Cwd::cwd();
    my $time = localtime;

    my $fh;
    if (not system "which less > /dev/null 2>&1") {
        open $fh, q(|-), 'less', '-FXR';
    }
    else {
        $fh = \*STDOUT;
    }

    say { $fh } App::Watson::UI->header("Run in: $pwd", "Run at: $time");

    # Display output for each file parsed
    for my $entry (@entries) {
        say { $fh } $_ for directory_report($entry, $tags);
    }

    close $fh if fileno($fh) != fileno(STDOUT);

    return 1;
}

sub directory_report {
    my ($dir, $tags) = @_;

    my @report;
    push @report, file_report(     $_, $tags) for @{ $dir->{files} };
    push @report, directory_report($_, $tags) for @{ $dir->{dirs}  };
    return @report;
}

sub file_report {
    my ($file, $tags) = @_;

    # Go through and see if there are any issues with given file
    # Sets print color and whether to continue to print
    my $issueflag = grep { 0 + @{$file->{$_}} } @$tags;
    my $fancy_filename = UNDERLINE $file->{filename};

    # If there are no issues, don't print anything (go to next file)
    # Else, continue on and print the issues
    if (not $issueflag) {
        return App::Watson::UI->success($fancy_filename);
    }

    my @report;
    push @report,
        q(),
        App::Watson::UI->error($fancy_filename);

    # Cycle through all tags and print issues for each
    for my $tag (@$tags) {
        my @issues = @{$file->{$tag}} or next;

        # Print tag, line #, and issue

        my @lines;
        for my $issue (@issues) {
            # Check if issue has been closed on Github or Bitbucket, set to resolved
            my @solved_on =
                map  { App::Watson::UI->tag(BOLD GREEN "Resolved on " . $_->name) }
                grep { $_->closed_issues->contains($issue->md5) }
                values %REPOSITORIES;

            push @lines, [
                [RESET, WHITE "  line " . $issue->line, RESET],
                RESET, BOLD, $issue->comment, RESET, @solved_on,
            ];
        }
        push @report,
            App::Watson::UI->tag(BOLD BLUE $tag),
            App::Watson::UI->details(@lines);
    }

    return @report;
}

#####################
# Repository Classes
#####################

BEGIN {
}

BEGIN {
    package App::Watson::Repository::GitHub;
    use parent -norequire, 'App::Watson::Repository';

    sub name {
        return "GitHub";
    }
}

BEGIN {
    package App::Watson::Repository::Bitbucket;
    use parent -norequire, 'App::Watson::Repository';

    sub name {
        return "Bitbucket";
    }
}


###########################################################
# GitHub Setup
###########################################################

# Obtain API key for either Github
sub App::Watson::Repository::GitHub::setup {
    my $self = shift;

    say App::Watson::UI->header();

    say App::Watson::UI->info(
        'Obtaining OAuth Token for GitHub...',
        q(),
    );

    # Parse config to make sure no previous API exists
    App::Watson::parse_config() if App::Watson::check_config();

    if (defined $self->api or defined $self->repo) {
        say App::Watson::UI->warning('Previous GitHub API + Repo is in RC, are you sure you want to overwrite?');
        my $overwrite = App::Watson::UI->prompt_yn(default => 'N');
        say q();

        if (not $overwrite) {
            say App::Watson::UI->error('Not overwriting current GitHub API + repo info');
            exit 1;
        }
    }

    say App::Watson::UI->info(
        'Access to your GitHub account required to make/update issues',
        'See help or README for more details on GitHub/Bitbucket access',
        q(),
    );

    # Get username, clear newlines surrounding text
    # If blank, give error
    $self->username(lc App::Watson::UI->prompt(
        'Username:',
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter your username!');
            exit 1;
        },
    ));
    $self->password(App::Watson::UI->prompt(
        'Password:',
        silent => 1,
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter your password!');
            exit 1;
        },
    ));

    # fetch an access token from GitHub
    $self->authorization;
    say RESET;

    # Get repo information
    # If blank, give error
    say App::Watson::UI->info(
        'Repo information required',
        'Please provide owner that repo is under followed by repo name',
        'e.g. owner: "nhmood", repo: "watson" (case insensitive)',
        'See help or README for more details on GitHub access',
        q(),
    );

    my $owner = lc App::Watson::UI->prompt(
        'Owner:',
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter the owner the repo is under!');
            exit 1;
        },
    );
    my $repo = lc App::Watson::UI->prompt(
        'Repo:',
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter the repo name!');
            exit 1;
        },
    );
    $self->repo("$owner/$repo");

    $self->test_access;

    say App::Watson::UI->info(
        'Creating label for watson on GitHub...',
        q(),
    );
    $self->create_label('watson', '00AEEF');

    Configuration->replace_sections($RCNAME,
        github     => [$self->access_token],
        githubrepo => [$self->repo],
    );

    say App::Watson::UI->success(
        'GitHub successfully setup',
        'Issues will now automatically be updated on GitHub by default',
        'See help or README for more details on GitHub/Bitbucket access',
        q(),
    );
    exit 0;
}

sub App::Watson::Repository::GitHub::create_label {
    my ($self, $name, $color) = @_;

    my $response = App::Watson::UserAgent->post(
        sprintf('https://api.github.com/repos/%s/labels', $self->repo),
        Authorization => $self->authorization,
        JSON => 1,
        Content => {
            name => $name,
            color => $color,
        },
    );

    if ($response->code == App::Watson::UserAgent::HTTP_CREATED) {
        say App::Watson::UI->success("Label successfully created");
    }
    elsif ($response->decoded_content =~ m/already_exists/i) {
        say App::Watson::UI->info("Label already exists");
    }
    else {
        say App::Watson::UI->error("Unable to access /repo/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]})");
        exit 1;
    }
    say q();

    return;
}

sub App::Watson::Repository::GitHub::authorization {
    my $self = shift;

    return $self->{'App::Watson::Repository::GitHub/authorization'} //= do {
        if (not defined $self->access_token) {
            my $basic_authorization = 'Basic ' . MIME::Base64::encode(
                $self->username . q(:) . $self->password, q()
            );

            my $response = App::Watson::UserAgent->post(
                'https://api.github.com/authorizations',
                Authorization => $basic_authorization,
                JSON => 1,
                Content => {
                    scopes   => ['repo'],
                    note     => 'watson',
                    note_url => 'http://watson.goosecode.com',
                },
            );

            if ($response->code != App::Watson::UserAgent::HTTP_CREATED) {
                say App::Watson::UI->error("Unable to obtain OAuth Token");
                exit 1;
            }
            say App::Watson::UI->success("Obtained OAuth Token");

            my $dsc = $response->json;
            my $access_token = $dsc->{token};

            if (not defined $access_token) {
                Carp::croak "The returned JSON did not contain an access token.\n", Data::Dumper::Dump($dsc);
            }

            $self->access_token($access_token);
        }

        'token ' . $self->access_token;
    };
}

sub App::Watson::Repository::GitHub::test_access {
    my $self = shift;

    my $response = App::Watson::UserAgent->get(
        sprintf('https://api.github.com/repos/%s/issues', $self->repo),
        Authorization => $self->authorization,
    );

    if (not $response->is_success) {
        say App::Watson::UI->error("Unable to access /repos/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]}).");
        exit 1;
    }

    say App::Watson::UI->success("Repo successfully accessed");
    return 1;
}


###########################################################
# Bitbucket Setup
###########################################################

# Set up Bitbucket access
# [todo] - Only basic http auth, get OAuth for Bitbucket
# Bitbucket OAuth needs to redirect to some grant access page
# Not sure how to do that with a CLI, basic HTTP auth for now

sub App::Watson::Repository::Bitbucket::setup {
    my $self = shift;

    # Set remote setup to one so password isn't asked for in Bitbucket parse_config section
    # Crappy fix, won't need this when OAuth is implemented for Bitbucket
    $REMOTESETUP = 1;

    say App::Watson::UI->header();

    say App::Watson::UI->info("Attempting to access Bitbucket...");

    # Parse config to make sure no previous API exists
    App::Watson::parse_config() if App::Watson::check_config();

    if (defined $self->access_token or defined $self->repo) {
        say App::Watson::UI->warning('Previous Bitbucket Repo is in RC, are you sure you want to overwrite?');
        my $overwrite = App::Watson::UI->prompt_yn(default => 'N');
        say q();

        if (not $overwrite) {
            say App::Watson::UI->error("Not overwriting current Bitbucket repo info");
            exit 1;
        }
    }

    say App::Watson::UI->info(
        "Access to your Bitbucket account required to make/update issues",
        "See help or README for more details on GitHub/Bitbucket access",
        q(),
    );
    say App::Watson::UI->warning(
        "Bitbucket OAuth not implemented yet.",
        "Basic HTTP Auth in use, will request PW entry every time.",
        q(),
    );

    my $username = lc App::Watson::UI->prompt(
        'Username:',
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter your username!');
            exit 1;
        },
    );
    $self->username($username);
    $self->access_token($username);

    my $password = App::Watson::UI->prompt(
        'Password:',
        silent  => 1,
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter your password!');
            exit 1;
        },
    );
    $self->password($password);

    # Get repo information
    # If blank, give error
    say App::Watson::UI->info(
        'Repo information required',
        'Please provide owner that repo is under followed by repo name',
        'e.g. owner: nhmood, repo: watson (case insensitive)',
        'See help or README for more details on GitHub access',
        q(),
    );

    my $owner = lc App::Watson::UI->prompt(
        'Owner:',
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter the owner the repo is under!');
            exit 1;
        },
    );
    my $repo = lc App::Watson::UI->prompt(
        'Repo:',
        default => sub {
            say App::Watson::UI->error('Input blank. Please enter the repo name!');
            exit 1;
        },
    );
    say q();
    $self->repo("$owner/$repo");

    $self->test_access;
    say q();

    Configuration->replace_sections($RCNAME,
        bitbucket     => [$self->access_token],
        bitbucketrepo => [$self->repo],
    );

    say App::Watson::UI->success(
        'Bitbucket successfully set up.',
        'Issues will now automatically be updated on Bitbucket by default',
        'Use -l, --local to not update against GitHub',
        'See help or README for more details on GitHub/Bitbucket access',
        q(),
    );

    exit 0;
}

sub App::Watson::Repository::Bitbucket::authorization {
    my $self = shift;
    return $self->{'App::Watson::Repository::Bitbucket/authorization'} //= do {
        'Basic ' . MIME::Base64::encode($self->username . q(:) . $self->password, q());
    };
}

sub App::Watson::Repository::Bitbucket::test_access {
    my $self = shift;

    my $response = App::Watson::UserAgent->get(
        (sprintf 'https://bitbucket.org/api/1.0/repositories/%s', $self->repo),
        Authorization => $self->authorization,
    );

    if (not $response->is_success) {
        say App::Watson::UI->error(
            'Unable to access remote repo with given credentials',
            'Check that credentials are correct and that the repository exists under the owner.',
        );
        exit 1;
    }

    say App::Watson::UI->success("Successfully accessed remote repo with given credentials");
    return 1;
}


###########################################################
# Repository Issue Getter
###########################################################

sub App::Watson::Repository::fetch_issues_ok { ... }
sub App::Watson::Repository::fetch_issues_open_url { ... }
sub App::Watson::Repository::fetch_issues_closed_url { ... }
sub App::Watson::Repository::fetch_issues_extract_issues { ... }

sub App::Watson::Repository::fetch_issues {
    my ($self) = @_;
    my $name = $self->name;

    return unless $self->fetch_issues_ok;

    App::Watson::debug_print("Getting $name Issues\n");

    my $response = App::Watson::UserAgent->get(
        $self->fetch_issues_open_url,
        Authorization => $self->authorization,
    );

    if (not $response->is_success) {
        $self->valid(0);
        say App::Watson::UI->warning(
            'Unable to access remote',
            "The $name settings may be invalid. Consider running watson with the --remote option to regenerate the settings.",
            q(),
        );
        return;
    }

    $self->valid(1);
    $self->open_issues->add($_) for
        $self->fetch_issues_extract_issues($response->json);
    App::Watson::debug_print(Data::Dumper::Dump($self->open_issues));

    $response = App::Watson::UserAgent->get(
        $self->fetch_issues_closed_url,
        Authorization => $self->authorization,
    );

    if (not $response->is_success) {
        $self->valid(0);
        say App::Watson::UI->warning("Could not get closed issues on $name, ignoring.");
        return;
    }

    $self->closed_issues->add($_) for
        $self->fetch_issues_extract_issues($response->json);
    App::Watson::debug_print(Data::Dumper::Dumper($self->closed_issues));

    return;
}

# GitHub Implementation

sub App::Watson::Repository::GitHub::fetch_issues_ok {
    my $self = shift;

    return 1 if defined $self->access_token;
    debug_print("No GitHub access token, ignoring issue list\n");
    return;
}

sub App::Watson::Repository::GitHub::fetch_issues_open_url {
    my $self = shift;

    return sprintf 'https://api.github.com/repos/%s/issues?labels=watson&state=open', $self->repo;
}

sub App::Watson::Repository::GitHub::fetch_issues_closed_url {
    my $self = shift;

    return
    sprintf 'https://api.github.com/repos/%s/issues?labels=watson&state=closed', $self->repo;
}

sub App::Watson::Repository::GitHub::fetch_issues_extract_issues {
    my ($self, $data) = @_;

    return
        grep { defined $_ }
        map  { App::Watson::Issue->reconstruct(@$_{qw<title body>}) }
        @$data;
}

# Bitbucket Implementation

sub App::Watson::Repository::Bitbucket::fetch_issues_ok {
    my $self = shift;

    return 1 if defined $self->repo;
    App::Watson::debug_print("No Bitbucket Repo, ignoring issue list\n");
    return;
}

sub App::Watson::Repository::Bitbucket::fetch_issues_open_url {
    my $self = shift;

    return sprintf 'https://bitbucket.org/api/1.0/repositories/%s/issues', $self->repo;
}

sub App::Watson::Repository::Bitbucket::fetch_issues_closed_url {
    my $self = shift;

    return sprintf 'https://bitbucket.org/api/1.0/repositories/%s/issues?status=resolved', $self->repo;
}

sub App::Watson::Repository::Bitbucket::fetch_issues_extract_issues {
    my ($self, $data) = @_;

    return
        grep { defined $_ }
        map  { App::Watson::Issue->reconstruct(@$_{qw<title content>}) }
        @{ $data->{issues} };
}


##########################
# Repository Issue Poster
##########################

sub App::Watson::Repository::post_issue_url { ... }
sub App::Watson::Repository::post_issue_headers {
    return ();
}

sub App::Watson::Repository::post_issue {
    my ($self, $_issue) = @_;
    my $url     = $self->post_issue_url;
    my %headers = $self->post_issue_headers;

    return unless defined $self->access_token;

    my $issue = App::Watson::Issue->new(
        path => $_issue->{file},
        line => $_issue->{linenumber},
        tag  => $_issue->{tag},
        comment => $_issue->{comment},
    );

    # Check if md5 of issue has already been posted
    # [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
    return if $self->open_issues->contains($issue->md5);
    return if $self->closed_issues->contains($issue->md5);

    # [todo] - figure out it the formatting actually works as expected
    my $response = App::Watson::UserAgent->post(
        $url,
        Authorization => $self->authorization,
        Content => {
            title   => $issue->title,
            content => $issue->formatted_data,
        },
        %headers,
    );

    if (not $response->is_success) {
        # [todo] - better error handling
        return;
    }

    App::Watson::debug_print($response->decoded_content);

    return;
}

# Github Implementation

sub App::Watson::Repository::GitHub::post_issue_url {
    my ($self) = @_;
    return sprintf 'https://api.github.com/repos/%s/issues', $self->repo;
}

sub App::Watson::Repository::GitHub::post_issue_headers {
    return (JSON => 1);
}

# Bitbucket Implementation

sub App::Watson::Repository::Bitbucket::post_issue_url {
    my ($self) = @_;
    return sprintf 'https://api.github.com/repos/%s/issues', $self->repo;
}