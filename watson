#!/usr/bin/perl
package App::Watson;
# watson - inline issue manager
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# This content is licensed under the MIT License
# See the file LICENSE for copying permission


# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - wrap printed lines around 80 characters
# [todo] - command line option to remove remote repos
# [todo] - replace json parser with just grep? need to get status if failed
# [todo] - add ability to update issue if same title but different md5
# [todo] - implement local only reporting (make it default?)
# [todo] - progress bar for obtaining github/bitbucket issue list
# [todo] - local should be default, must use -r or remote flag to post and check?
#		 - maybe have it check against background unless -local is passed
#		 - but dont post unless --post is used (make it faster?)
# [todo] - add status indicator for remote requests
#		 - we know # of requests and which we are on, can do it that way
# [todo] - change github issue checks to -d instead of issue?key=val
# [todo] - add remote / local options and necessary logic
# [todo] - replace open/closed issue var with just all and closed?

###########################################################
# Global parameters
###########################################################

use strict;
use feature qw< say state >;  # implies dependency on perl 5.010
use autodie; # in Core since 5.010
use warnings;

# For color print outs
use Term::ANSIColor qw< :constants >;

local $SIG{INT} = sub {
	print "\n";
	exit 1;
};

# For debugging (print data structures)
use Data::Dumper;

# For MD5 Sum (issue posting check)
use Digest::MD5 qw<>;

use JSON qw<>;  # [todo] - list JSON as external dependency
# [todo] - list LWP::UserAgent as optional external dependency

use File::Copy qw<>;   # in Core since 5.002
use MIME::Base64 qw<>; # in Core since 5.007.003
use Carp qw<>;         # in Core since 5.000
use Encode qw<>;       # in Core since 5.007.003
use IO::Handle qw<>;   # in Core since 5.003.07
use Cwd qw<>;          # in Core since 5.000
use English qw< -no_match_vars >; # in Core since 5
use Hash::Util qw< lock_keys >;   # in Core since 5.008

# App Config
our $DEBUG = $ENV{WATSON_DEBUG};
our $RCNAME = ".watsonrc";		# Change config file name
our $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
our @DIRS;
our @FILES;
our @TAGS;
our @IGNORE;
our $REMOTESETUP = 0;
our $MAX_DEPTH = 0;
lock_keys(our %IGNORE_RC, qw<dirs files tags ignore>);
our $HASLESS = 0;
our $HASCURL = 0;
our $LESSOUT;

our $GITHUB    = App::Watson::Repository::GitHub->new;
our $BITBUCKET = App::Watson::Repository::Bitbucket->new;

our %REPOSITORIES = (
	github    => $GITHUB,
	bitbucket => $BITBUCKET,
);

END {
	unlink $TMPOUT if $HASLESS;
}

exit main(@ARGV);

#----------------------------------------------------------
###########################################################
# Main Program
###########################################################
#----------------------------------------------------------

sub main {
	check_less();

	my $pwd = Cwd::cwd();
	my $time = localtime;
	wprint(header("Run in: $pwd", "Run \@: $time"), "\n");

	parse_command_line();
	check_config();
	parse_config();
	my @issue_tree = start_scan();
	create_report(@issue_tree);
	return 0;
}

#----------------------------------------------------------
###########################################################
# Functions
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print
###########################################################

sub header {
	my @info = @_;
	unshift @info, q() if @info;  # adds an empty line before further info
	# Each line is a string or an arrayref of strings
	# Here, we flatten them (if applicable), add a newline,
	# and return a single string.
	return join q(), map { join q(), ( ref $_ ? @$_ : $_ ), "\n" }
		[BOLD "------------------------------"],
		[BOLD "watson", RESET, " - ", BOLD YELLOW "inline issue manager", RESET],
		@info,
		[BOLD "------------------------------"],
		q();
}

###########################################################
# Help Print
###########################################################

# Print watson help
sub print_help {
	print BOLD, <<'END_HELP', RESET;
Usage: watson [OPTION]...
Running watson with no arguments will parse with settings in RC file
If no RC file exists, default RC file will be created

   -d, --dirs			list of directories to search in
   -f, --files			list of files to search in
   -h, --help			say help
   -i, --ignore			list of files, directories, or types to ignore
   -p, --parse-depth		depth to recursively parse directories
   -r, --remote			list / create tokens for Bitbucket/Github
   -t, --tags			list of tags to search for
   -v, --version		say watson version and info

Any number of files, tags, dirs, and ignores can be listed after flag
Ignored files should be space separated
To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions


Report bugs to: watson\@goosecode.com
watson home page: <http://goosecode.com/projects/watson>
[goosecode] labs | 2012-2013";
END_HELP

	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub print_version {
	print <<'END_VERSION';
watson v1.3
Copyright (c) 2012-2013 goosecode labs
Licensed under MIT, see LICENSE for details

Written by nhmood, see <http://goosecode.com/projects/watson>
END_VERSION

	return 1;
}

###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debug_print {
	my @strings = @_;
	return print @strings if $DEBUG;
	return;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	my @strings = @_;
	if ($HASLESS){
		print { $LESSOUT } @strings;
		return 1;
	}
	else {
		print @strings;
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub check_less {
	return $HASLESS if defined $HASLESS;
	$HASLESS //= not system "which less > /dev/null 2>&1";
	return 0 unless $HASLESS;
	open $LESSOUT, "+>", $TMPOUT;  ## no critic (InputOutput::RequireBriefOpen)
	return 1;
}

###########################################################
# Directory checker
###########################################################

# check_dir - checks if directory can be opened
# Different from just using -d, checks if able to OPEN
sub check_dir {
	my ($dir) = @_;

	# Error check for input
	if (not length $dir) {
		wprint("No directories specified.\n");
		return 0;
	}

	# Check if directory can be opened
	opendir my $tDIR, $dir or do {
		wprint(qq{Cannot open dir "$dir": $!\n});
		return 0;
	};

	closedir $tDIR;
	debug_print(qq{"$dir" exists and opened successfully.\n});
	return 1;
}


###########################################################
# File checker
###########################################################

# check_file - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub check_file {
	my ($file) = @_;

	# Error check for input
	if (not length $file) {
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	open my $tFILE, '<', $file or do {
		wprint(qq{Could not open "$file": $!\n});
		return 0;
	};

	close $tFILE;
	debug_print(qq{"$file" exists and opened successfully.\n});
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub check_config {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects

	# Check for rc
	debug_print("[Checking for $RCNAME]\n");
	if (-e $RCNAME) {
		debug_print("$RCNAME found\n\n");
		return 1;
	}
	else {
		debug_print("$RCNAME not found!\n");
		debug_print("Creating default $RCNAME\n");

		# Create default rc
		create_rc($RCNAME);
		return 0;
	}
}


###########################################################
# Default config file writer
###########################################################

# Create default RC file with some generic settings
sub create_rc {
	my ($file_name) = @_;

# [fixme] - Figure out a way to indent this?
my $rcdefault = <<'EOF';
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories
[dirs]
./


# Tags
[tags]
fix
review
todo


# Ignores
[ignore]
.git
.swp
EOF

	debug_print($rcdefault);

	# Print default rc above to specified file
	open my $file, "+>>", $file_name;
	my $success = print { $file } $rcdefault;
	close $file;

	return $success;
}


###########################################################
# Command line parser
###########################################################

# Parse command line arguments
sub parse_command_line {
	debug_print("[Checking CL args]\n");
	debug_print("Total args: ", $#ARGV + 1, "\n");

	my %long_opts = (
		"-d" => "--dirs",
		"-f" => "--files",
		"-h" => "--help",
		"-v" => "--version",
		"-t" => "--tags",
		"-p" => "--parse-depth",
		"-i" => "--ignore",
		"-r" => "--remote",
	);
	my %opts;
	@opts{%long_opts} = ();

	my $slurp_items = sub {
		my ($cb) = @_;

		# Keep checking following options until another flag or end
		while (@ARGV) {
			# stop when the current item is a known flag
			last if exists $opts{$ARGV[0]};

			my $item = shift @ARGV;
			$cb->($item);
		}
	};

	my %flag_actions = (
		'--help' => sub {
			debug_print("Help flag passed\n");
			print_help();
			exit 0;
		},
		'--version' => sub {
			debug_print("Version flag passed\n");
			print_version();
			exit 0;
		},
		'--parse-depth' => sub {
			debug_print("Parse Depth flag passed\n");
			# Check to make sure next param is a valid number (non-negative)

			if (not @ARGV) {
				wprint(box(BOLD RED "x"), "--parse-depth requires a numeric argument\n");
			}

			my $depth = shift @ARGV;

			if ($depth =~ /[^0-9]/) {
				wprint(box(BOLD MAGENTA q(!)));
				wprint("--> ", RESET);
				wprint("Invalid parse depth passed\n");
				return;
			}

			$MAX_DEPTH = $depth;
			debug_print("Valid parse depth: $MAX_DEPTH\n");
		},
		'--remote' => sub {
			debug_print("Remote Flag passed\n");

			# When generating OAuth Token for github/bitbucket
			# no other params should be passed
			if (@ARGV > 1){
				debug_print("Not the only flag, exiting\n");
				print box(BOLD RED "x");
				print "Please run remote flag alone to generate GitHub/Bitbucket OAuth token\n";
				print "      See help for more details\n";
				exit 1;
			}

			# Can only do this if we have cURL on the system
			if (not $HASCURL) {
				print box(BOLD RED "x");
				print "It looks like you don't have cURL\n";
				print "      We currently only support remote issues if you have cURL\n";
				print "      Make sure cURL is installed and in your PATH\n";
				exit 1;
			}

			my $service = lc shift @ARGV;

			if (my $repo = $REPOSITORIES{$service}) {
				$repo->setup;
			}
			elsif ($service eq q()) {
				parse_config() if check_config();

				if (not defined $BITBUCKET->access_token and not defined $GITHUB->access_token) {
					say box_error("No remotes currently exist");
					say BOLD "      Pass github or bitbucket to watson -r to add", RESET;
					say "      That's all we support right now :(";
					say "      See help for more details";
					exit 1;
				}

				if (defined $BITBUCKET->access_token) {
					print box(BOLD GREEN "Bitbucket"), qq(\n);
					say BOLD "   Bitbucket User :", RESET, q( ), $BITBUCKET->access_token;
					say BOLD "   Bitbucket Repo :", RESET, q( ), $BITBUCKET->repo;
					say q();
				}

				if (defined $GITHUB->access_token) {
					say box(BOLD GREEN "GitHub");
					say BOLD "   GitHub Key  :", RESET, q( ), $GITHUB->access_token;
					say BOLD "   GitHub Repo :", RESET, q( ), $GITHUB->repo;
					say q();
				}

				exit 1;
			}
			else {
				say box_error("Incorrect argument");
				say for
					"      Please specify either github or bitbucket to setup remote",
					"      Or pass without argument to see current remotes",
					"      See help for more details";
				exit 1;
			}
		},
		'--dirs' => sub {
			debug_print("Dir flag passed\n");
			$slurp_items->(sub {
				my ($dir) = @_;
				debug_print("Dir Index: $dir\n");

				if (check_dir($dir)) {
					debug_print("dirflag: {$dir} valid directory, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debug_print("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC{dirs} = 1;

					# Remove trailing slashes
					$dir =~ s{/+\z}{};
					push @DIRS, $dir;
				}
			});
		},
		'--files' => sub {
			debug_print("File flag passed\n");
			$slurp_items->(sub {
				my ($file) = @_;
				debug_print("File Index: $file\n");

				if (check_file($file)) {
					debug_print("fileflag: {$file} valid file, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debug_print("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC{files} = 1;

					push @FILES, $file;
					}
			});
		},
		'--tags' => sub {
			debug_print("Tag flag passed\n");
			$slurp_items->(sub {
				my ($tag) = @_;
				debug_print("Tag Index: $tag\n");
				debug_print("tagflag: {$tag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debug_print("Ignoring RC tags\n\n");
				$IGNORE_RC{tags} = 1;

				push @TAGS, $tag;
			});
		},
		'--ignore' => sub {
			debug_print("Tag flag passed\n");
			$slurp_items->(sub {
				my ($ignoreflag) = @_;
				debug_print("Ignore Index: $ignoreflag\n");
				debug_print("ignoreflag: {$ignoreflag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debug_print("Ignoring RC ignore\n\n");
				$IGNORE_RC{ignore} = 1;

				push @IGNORE, $ignoreflag;
			});
		},
	);

	# add the short names for each flag
	for my $key (keys %long_opts) {
		$flag_actions{$key} = $flag_actions{$long_opts{$key}}
			or warn "The option $long_opts{$key} is not implemented";
	}

	if (not @ARGV) {
		debug_print("No command line arguments passed.\n\n");
		return;
	}

	while (@ARGV) {
		my $item = shift @ARGV;
		debug_print("Main Item: $item\n");

		my $action = $flag_actions{$item}
			or die qq{Can't understand command line argument "$item"};
		$action->();
	}

	return 1;
}


###########################################################
# Config file parser
###########################################################

BEGIN {
	package App::Watson::Configuration;
	use English qw<-no_match_vars>; # in Core since 5

	sub new_from_file {
		my ($class, $filename) = @_;

		my %sections;

		my $section;
		open my $fh, "<", $filename;
		while (<$fh>) {
			chomp;
			App::Watson::debug_print("# line $INPUT_LINE_NUMBER: $_\n");

			next if !/\S/;
			next if /\A\s*#/;

			if (/\A \[( \w+ )\] \s*\z/x) {
				$section = lc $1;
				App::Watson::debug_print("# recognized as section [$section]\n");
				next;
			}

			die qq/No section specified at "$filename" line $INPUT_LINE_NUMBER./
				unless defined $section;

			push @{ $sections{$section} }, $_;
			App::Watson::debug_print("# added to [$section]\n");
		}
		close $fh;

		return bless {
			sections => \%sections,
		} => $class;
	}

	sub sections {
		my ($self) = @_;
		return $self->{sections};
	}

	sub section {
		my ($self, @other_args) = @_;
		Carp::croak qq/Argument "name" is required/ unless @other_args;
		my $name = shift @other_args;
		Carp::croak "name must be defined" unless defined $name;
		return $self->{sections}{$name} if exists $self->{sections}{$name};
		return my $default = shift @other_args if @other_args;
		Carp::croak qq/No entry for "$name" present, and no default given/;
	}

	sub section_names {
		my ($self) = @_;
		return keys %{ $self->{sections} };
	}

	sub replace_sections {
		my (undef, $filename, %replacements) = @_;

		# First, delete the old sections if applicable:

		my $nlc = 0;
		if (App::Watson::check_config()){
			my $section = q();
			open my $in,  "<", $filename;
			open my $out, ">", "$filename.new";
			while (<$in>){
				chomp;
				$section = lc $1 if /^\[(\w+)\]/;

				# Max 2 consecutive empty lines
				if (not /\S/) {
					$nlc++;
					if ($nlc <= 2) {
						say { $out } q();
						next;
					}
				}

				next if exists $replacements{$section};

				# This section won't be changed - copy everything over.
				say { $out } $_;
				$nlc = 0;  # Reset newline count
			}
			close $in;
			close $out;

			# Remove old RC file and replace with new one
			File::Copy::move("$filename.new" => $filename)
				or die qq{Can't move update RC at "$filename": $!};
		}

		# Now, append the new sections to the file (new or old, doesn't matter)

		open my $file, ">>", $filename;

		for my $section (sort keys %replacements) {
			# print remaining newlines
			say { $file } q() for $nlc .. 1;

			say { $file } "[$section]";
			say { $file } $_ for @{ $replacements{$section} };

			$nlc = 0;
		}

		close $file;

		return;
	}
}

# Go through config file and determine dirs, tags, and ignores to use
sub parse_config {
	# Parse rc
	debug_print("Parsing $RCNAME\n");

	# Add . and .. and .git to ignorelist
	push @IGNORE, qw< . .. *.swp .watsonrc >, $TMPOUT;

	my %actions = (
		# If @DIRS or @FILES wasn't populated by CL args, populate from rc
		dirs => sub {
			my $name = shift;
			if ($IGNORE_RC{dirs} || $IGNORE_RC{files}) {
				debug_print("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for dirs, then push to @DIRS
				$line =~ m{\A\s* ((?:[.]?/?\w?+/?)+) \s*\z}x
					or die qq{The line "$line" in a "dirs" section did not contain a valid path};
				(my $dir = $1) =~ s{/+\z}{};
				debug_print("dirs: $dir added from rc. \n");
				push @DIRS, $dir;
			}
		},
		# If @TAGS wasn't populated by CL args, populate from rc
		tags => sub {
			my $name = shift;
			if ($IGNORE_RC{tags}) {
				debug_print("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for tags, then push to @TAGS
				$line =~ /^\A\s* (\w+(?: [|] [0-9])?) \s*\z/x
					or die qq{The line "$line" in a "tags" section did not contain a valid tag};
				my $tag = $1;
				debug_print("tags: $tag added from rc.\n");
				push @TAGS, $tag;
			}
		},
		# If @IGNORE wasn't populated by CL args, populate from rc
		ignore => sub {
			my $name = shift;
			if ($IGNORE_RC{ignore}) {
				debug_print("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for dirs to ignore, then push to @IGNOREDIR
				$line =~ m{\A\s* (.+) \s*\z}x
					or die qq{The line "$line" in a "ignore" section did not contain a valid path};
				(my $path = $1) =~ s{(/)+\z}{};
				debug_print("ignore: $path added from rc.\n");
				push @IGNORE, $path;
			}
		},
		github => sub {
			my $name = shift;
			my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

			for my $api (@_) {
				say box_warn("The ", $repository->name, " API was already set, overwriting")
					if defined $repository->access_token;

				# No need for regex on API key
				debug_print($repository->name . "API: $api\n");
				$repository->access_token($api);
			}
		},
		githubrepo => sub {
			my $name = shift;
			$name =~ s/repo\z//;
			my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

			for my $repo (@_) {
				say box_warn("The ", $repository->name, "Repo was already set, overwriting")
					if defined $repository->repo;

				# No need for regex on repo
				debug_print($repository->name . "Repo: $repo\n");
				$repository->repo($repo);
			}

			# If setting up remote, don't ask for password / do any remote stuff
			# Won't need this when OAuth implemented but it does optimize the code...

			# Get list of issues, also checks if API key is valid
			$repository->fetch_issues unless $REMOTESETUP;
		},
	);
	$actions{bitbucket}     = $actions{github};
	$actions{bitbucketrepo} = $actions{githubrepo};

	my $config = App::Watson::Configuration->new_from_file($RCNAME);

	for my $section ($config->section_names) {
		my $action = $actions{$section} or die qq/Unknown section "$section"/;
		debug_print("[$section] contains [@{[$config->section($section)]}]\n");
		$action->($section => $_) for @{ $config->section($section) };
	}

	return 1;
}


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub start_scan{

	my @files_with_issues;

	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC{files}){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		push @files_with_issues, {
			files => [ map { parse_file($_) } @FILES ],
		};
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	push @files_with_issues, map { parse_directories($_) } @DIRS;

	wprint("\n");
	return @files_with_issues;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parse_directories {
	my ($dir, $depth) = @_;
	$depth //= 1;
	return if $MAX_DEPTH and $depth > $MAX_DEPTH;
	debug_print("parse_directories: |$dir| at depth $depth/$MAX_DEPTH\n");
	return unless check_dir($dir); # Error check for input

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	# Loop through all entries in directory
	debug_print(qq{Looping through all files/folders in "$dir"\n});

	# Open dir and get list of all files
	opendir my($wd), $dir;
	ENTRY: for my $entry (sort grep { not /\A [.][.]? \z/x } readdir $wd) {
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		debug_print("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		for my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so
			if (not ref $ignore) {
				($ignore) =
					map  { qr/\A$_\z/ }
					join q(.*) =>
					map  { quotemeta $_ }
					split /[*]/, $ignore;
			}
			if ($entry =~ /$ignore/) {
				debug_print("|$path| is on the ignore list, skipping\n");
				next ENTRY;
			}
		}

		# Check if entry is a file, if so parse
		if (-f $path) {
			debug_print("|$path| is a file!\n");
			push @pfiles, parse_file($path);
		}
		# Check if entry is dir, if so parse
		elsif (-d $path) {
			debug_print("|$path| is a dir!\n");
			push @pdirs, parse_directories($path, $depth + 1);
		}

		# Add directory to ignore list so it isn't repeated again
		push @IGNORE, $path;
	}

	closedir $wd;
	# Create has to hold all parsed files and folders
	return {
		files => \@pfiles,
		dirs => \@pdirs,
	};
}


###########################################################
# File Parser
###########################################################

sub parse_file {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debug_print("parse_file: |$file|\n");

	# Error check for input
	return unless check_file($file);

	# Get filetype and set corresponding comment type
	my $comment_regex = comment_regex($file);

	my %issue_list = (
		filename => $file,
		(map { $_ => [] } @TAGS),
	);

	# Read source file line by line
	open my $wf, "<", $file;
	while (<$wf>) {
		next unless /$comment_regex/x;
		my ($ftag, $fissue) = ($1, $2);
		App::Watson::debug_print(
			"Issue found!\n",
			"Tag: $ftag\n",
			"Issue: $fissue\n",
		);

		next unless exists $issue_list{$ftag};

		my $issue = App::Watson::Issue->new(
			path    => $file,
			line    => $INPUT_LINE_NUMBER,
			comment => $fissue,
			tag     => $ftag,
		);

		push @{ $issue_list{$ftag} }, $issue->as_hash;

		$issue->post;
	}
	close $wf;

	return \%issue_list;
}


###########################################################
# Comment setter
###########################################################

sub comment_regex {
	my ($file) = @_;

	state $watson_comment = qr/\s* \[(\S+)\] \s*[-]\s* (.+?) \s*/x;
	state $c_comment   = qr{(?<=[/][*]) $watson_comment (?=[*][/])}x;
	state $cpp_comment = qr{(?<=[/][/]) $watson_comment \z        }x;
	state $sh_comment  = qr{(?<=[\#])   $watson_comment \z        }x;

	# comments by their file endings. Each entry is a regex object
	#   that matches the whole comment.
	# Only single line comments are supported, this is a feature, not a bug.
	# [todo] - document this feature.
	state $comment = {};
	$comment->{$_} = qr/$cpp_comment | $c_comment/x for qw<cpp cc c h c++>;
	$comment->{$_} = $sh_comment for qw<sh rb pl pm>;

	# split the filename into it's various extensions
	my (undef, @extensions) =  split /[.]/, $file;

	# weigh the last extension highest
	# Ignore “extensions” with spaces in them: probably false positives
	for (grep { not /\s/ } reverse @extensions) {
		return $comment->{lc $_} // next;
	}

	say App::Watson::box_warn("Could not determine filetype for $file, using # as comment");
	return $sh_comment;
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub create_report {
	my (@entries) = @_;
	# Display output for each file parsed
	for my $entry (@entries){
		print_results($entry);
	}

	if ($HASLESS){
		system 'less', '-R', $TMPOUT and die qq(Couldn't open the tempfile "$TMPOUT" with "less");
		close $LESSOUT;
		# $TMPOUT is closed in end block
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub print_results {
	my ($entry) = @_;
	# Go through and print info for all files first
	for my $file_report (@{$entry->{files}}) {

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = grep { 0+@{$file_report->{$_}} } @TAGS;

		if ($issueflag){
			wprint("\n");
			wprint(box_error(UNDERLINE $file_report->{filename}), "\n");
		}
		else {
			wprint(box_ok(UNDERLINE $file_report->{filename}), "\n");
		}

		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		next unless $issueflag;

		# Cycle through all tags and print issues for each
		for my $tag (@TAGS){
			my @issues = @{$file_report->{$tag}} or next;

			# Print tag, line #, and issue
			wprint(box(BOLD BLUE $tag), "\n");

			for my $issue (@issues) {
				wprint(WHITE "  line $issue->{linenumber} - ", RESET, BOLD "$issue->{comment} ", RESET);

				# If valid API key
				# Check if issue has been closed on Github or Bitbucket, set to resolved
				for my $repo (values %REPOSITORIES) {
					wprint(box(BOLD GREEN "Resolved on " . $repo->name))
						if $repo->closed_issues->contains($issue->{md5});
				}

				wprint("\n");
			}
			wprint("\n");
		}
	}

	print_results($_) for @{$entry->{dirs}};

	return 1;
}

#####################
# Repository Classes
#####################

BEGIN {
	package App::Watson::Repository;

	my %prototype = (
		valid	=> 0,
		username => undef,
		password	=> undef,
		repo	=> undef,
		open_issues => undef,
		closed_issues => undef,
	);
	my @other_fields = qw<access_token>;

	my %lazy_init = (
		open_issues   => sub { App::Watson::IssueList->new },
		closed_issues => sub { App::Watson::IssueList->new },
	);

	sub new {
		my ($class, %args) = @_;

		if ($class eq __PACKAGE__) {
			Carp::croak "This class is abstract and should not be instantiated";
		}

		my $self = {%prototype};
		for my $field (grep { exists $args{$_} } @other_fields, keys %prototype) {
			$self->{__PACKAGE__ . q(/) . $field} = delete $args{$field};
		}

		if (keys %args) {
			Carp::croak "Unknown constructor arguments [@{[join ', ', keys %args]}]";
		}

		return bless $self => $class;
	}

	# a bit of meta-programming: writing the accessors
	for my $field (keys %prototype, @other_fields) {
		my $init = $lazy_init{$field};
		my $full_field_name = __PACKAGE__ . q(/) . $field;

		no strict 'refs';  ## no critic (TestingAndDebugging::ProhibitNoStrict)

		*{ $field } = sub {
			my $self = shift;
			return $self->{$full_field_name}   = shift          if @_;
			return $self->{$full_field_name} //= $self->$init() if $init;
			return $self->{$full_field_name};
		}
	}

	sub name { ... }

	sub authorization { ... }

	sub api {
		return shift->access_token(@_);
	}

	sub user {
		return shift->username(@_);
	}

	sub pw {
		return shift->password(@_);
	}
}

BEGIN {
	package App::Watson::Repository::GitHub;
	use parent -norequire, 'App::Watson::Repository';

	sub name {
		return "GitHub";
	}
}

BEGIN {
	package App::Watson::Repository::Bitbucket;
	use parent -norequire, 'App::Watson::Repository';

	sub name {
		return "Bitbucket";
	}
}

BEGIN {
	package App::Watson::UserAgent;

	my $instance;

	sub instance {
		my ($self, @other_args) = @_;
		return $instance = shift @other_args if @other_args;
		require LWP::UserAgent;
		return $instance //= LWP::UserAgent->new;
	}

	sub post {
		my ($self, %headers) = @_;

		if (delete $headers{JSON} and my $data = delete $headers{Content}) {
			$headers{Content} = JSON::encode_json($data);
		}

		my $response = $self->instance->post(%headers);
		return bless $response => 'App::Watson::HTTP::Response';
	}

	sub get {
		my ($self, %headers) = @_;

		my $response = $self->instance->get(%headers);
		return bless $response => 'App::Watson::HTTP::Response';
	}

	use constant {
		HTTP_CREATED => 201,
	};
}

BEGIN {
	package App::Watson::HTTP::Response;
	use parent 'HTTP::Response';

	sub json {
		my $self = shift;
		my $utf8_encoded_content = Encode::encode('utf8', $self->decoded_content);
		return JSON::decode_json($utf8_encoded_content);
	}
}

BEGIN {
	package App::Watson::Issue;

	my @required_fields = qw< path line tag comment >;
	my @private_fields  = qw< md5 >;

	sub new {
		my ($class, %args) = @_;
		my $self = {};

		for my $field (@required_fields) {
			if (not exists $args{$field}) {
				Carp::croak qq/Constructor argument "$field" is mandatory/;
			}
			$self->{__PACKAGE__ . q(/) . $field} = delete $args{$field};
		}

		if (keys %args) {
			my $keys = join ", ", sort keys %args;
			Carp::croak "Unknown constructor arguments [$keys]";
		}

		bless $self => $class;

		$self->{__PACKAGE__ . '/md5'} =
			Digest::MD5::md5_hex($self->tag, $self->file, $self->comment);

		return $self;
	}

	for my $field (@required_fields, @private_fields) {
		no strict 'refs';  ## no critic (TestingAndDebugging::ProhibitNoStrict)
		*{ __PACKAGE__ . q(::) . $field } = sub {
			my $self = shift;
			return $self->{__PACKAGE__ . q(/) . $field};
		}
	}

	sub file {
		my $self = shift;

		(my $file = $self->path) =~ s{\A.*/}{};
		return $file;
	}

	sub post {
		my $self = shift;

		$_->post_issue($self) for grep { $_->valid } values %REPOSITORIES;

		return;
	}

	sub formatted_data {
		my $self = shift;

		return join q(), map { "$_\n" }
			"__filename__ : " . $self->path,
			"__line #__ : "   . $self->line,
			"__tag__ : "      . $self->tag,
			"__md5__ : "      . $self->md5;
	}

	sub title {
		my $self = shift;

		return sprintf "%s [%s]", $self->comment, $self->file;
	}

	sub as_hash {
		my ($self) = @_;
		return +{
			linenumber => $self->line,
			comment    => $self->comment,
			tag        => $self->tag,
			file       => $self->file,
			md5        => $self->md5,
		};
	}

	sub reconstruct {
		my ($class, $title, $formatted_data) = @_;
		$title =~ /\A\s* (.+) \s* \[([^\]]+)\] \s*\z/x or return;
		my $comment= $1;
		my $file   = $2;
		$formatted_data =~ /^\s*__filename__\s:\s+(.+           ) \s*$/mx or return;
		my $path   = $1;
		$formatted_data =~ /^\s*__line \#__ \s:\s+([0-9]+       ) \s*$/mx or return;
		my $line   = $1;
		$formatted_data =~ /^\s*__tag__     \s:\s+(\w+          ) \s*$/mx or return;
		my $tag    = $1;
		$formatted_data =~ /^\s*__md5__     \s:\s+([[:xdigit:]]+) \s*$/mx or return;
		my $digest = $1;

		my $instance = (ref $class || $class)->new(
			path => $path,
			line => $line,
			comment => $comment,
			tag => $tag,
		);

		$instance->{'App::Watson::Issue/md5'} = $digest;

		return $instance;
	}
}


###########################################################
# GitHub Setup
###########################################################

# Obtain API key for either Github
sub App::Watson::Repository::GitHub::setup {
	my $self = shift;

	say App::Watson::header();

	say App::Watson::box(BOLD GREEN q(+)), BOLD "Obtaining OAuth Token for GitHub...\n", RESET;

	# Parse config to make sure no previous API exists
	App::Watson::parse_config() if App::Watson::check_config();

	if (defined $self->api or defined $self->repo) {
		my $overwrite = uc App::Watson::prompt(
			{ default => q(N) },
			App::Watson::box(BOLD RED q(!)),
			BOLD "Previous GitHub API + Repo is in RC, are you sure you want to overwrite?\n", RESET,
			"      (Y)es/(N)o: ",
		);
		say q();

		if ($overwrite =~ /\A (?: NO | N )? \z/x) {
			say App::Watson::box_error("Not overwriting current GitHub API + repo info");
			exit 1;
		}
	}

	say for
		App::Watson::box_info("Access to your GitHub account required to make/update issues"),
		"      See help or README for more details on GitHub/Bitbucket access",
		q();

	# Get username, clear newlines surrounding text
	# If blank, give error
	$self->username(App::Watson::prompt(BOLD "Username: ", RESET, {
		default => sub {
			say App::Watson::box_error("Input blank. Please enter your username!");
			exit 1;
		},
	}));

	$self->password(App::Watson::prompt(BOLD "Password: ", RESET, {
		echo => 0,
		default => sub {
			say App::Watson::box_error("Input blank. Please enter your password!");
			exit 1;
		},
	}));

	# fetch an access token from GitHub
	$self->authorization;
	say RESET;

	# Get repo information
	# If blank, give error
	say for
		App::Watson::box_info(BOLD "Repo information required"),
		"      Please provide owner that repo is under followed by repo name",
		"      e.g. owner: nhmood, repo: watson (case sensitive)",
		"      See help or README for more details on GitHub access",
		q();

	my $owner = App::Watson::prompt(BOLD "Owner: ", RESET, {
		default => sub {
			say App::Watson::box_error("Input blank. Please enter the owner the repo is under!");
			exit 1;
		},
	});
	my $repo = App::Watson::prompt(BOLD "Repo: ", RESET, {
		default => sub {
			say App::Watson::box_error("Input blank. Please enter the repo name!");
			exit 1;
		},
	});
	$self->repo("$owner/$repo");

	$self->test_access;

	say App::Watson::box_error("Creating label for watson on GitHub...\n");
	$self->create_label("watson", "00AEEF");

	Configuration->replace_sections($RCNAME,
		github     => [$self->access_token],
		githubrepo => [$self->repo],
	);

	say for
		App::Watson::box_ok("GitHub successfully setup"),
		"      Issues will now automatically be updated on GitHub by default",
		"      See help or README for more details on GitHub/Bitbucket access",
		q();
	exit 0;
}

sub App::Watson::Repository::GitHub::create_label {
	my ($self, $name, $color) = @_;

	my $response = App::Watson::UserAgent->post(
		sprintf('https://api.github.com/repos/%s/labels', $self->repo),
		Authorization => $self->authorization,
		JSON => 1,
		Content => {
			name => $name,
			color => $color,
		},
	);

	if ($response->code == App::Watson::UserAgent::HTTP_CREATED) {
		say App::Watson::box_ok("Label successfully created");
	}
	elsif ($response->decoded_content =~ m/already_exists/i) {
		say App::Watson::box_info("Label already exists");
	}
	else {
		say App::Watson::box_error("Unable to access /repo/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]})");
		exit 1;
	}
	say q();

	return;
}

sub App::Watson::Repository::GitHub::authorization {
	my $self = shift;

	return $self->{'App::Watson::Repository::GitHub/authorization'} //= do {
		if (not defined $self->access_token) {
			my $basic_authorization = 'Basic ' . MIME::Base64::encode(
				$self->username . q(:) . $self->password, q()
			);

			my $response = App::Watson::UserAgent->post(
				'https://api.github.com/authorizations',
				Authorization => $basic_authorization,
				JSON => 1,
				Content => {
					scopes   => ['repo'],
					note     => 'watson',
					note_url => 'http://watson.goosecode.com',
				},
			);

			if ($response->code != App::Watson::UserAgent::HTTP_CREATED) {
				say box_error("Unable to obtain OAuth Token");
				exit 1;
			}
			say box_ok("Obtained OAuth Token");

			my $dsc = $response->json;
			my $access_token = $dsc->{token};

			if (not defined $access_token) {
				Carp::croak "The returned JSON did not contain an access token.\n", Data::Dumper::Dump($dsc);
			}

			$self->access_token($access_token);
		}

		'token ' . $self->access_token;
	};
}


sub App::Watson::Repository::GitHub::test_access {
	my $self = shift;

	my $response = App::Watson::UserAgent->get(
		sprintf('https://api.github.com/repos/%s/issues', $self->repo),
		Authorization => $self->authorization,
	);

	if (not $response->is_success) {
		say box_error("Unable to access /repos/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]}).");
		exit 1;
	}

	say box_ok("Repo successfully accessed");
	return 1;
}


###########################################################
# Bitbucket Setup
###########################################################

# Set up Bitbucket access
# [todo] - Only basic http auth, get OAuth for Bitbucket
# Bitbucket OAuth needs to redirect to some grant access page
# Not sure how to do that with a CLI, basic HTTP auth for now

sub App::Watson::Repository::Bitbucket::setup {
	my $self = shift;

	# Set remote setup to one so password isn't asked for in Bitbucket parse_config section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	say App::Watson::header();

	say App::Watson::box(BOLD GREEN q(+)), BOLD "Attempting to access Bitbucket...", RESET;

	# Parse config to make sure no previous API exists
	App::Watson::parse_config() if App::Watson::check_config();

	if (defined $self->access_token or defined $self->repo) {
		my $overwrite = uc App::Watson::prompt(
			{ default => q(N) },
			App::Watson::box(BOLD RED q(!)),
			BOLD "Previous Bitbucket Repo is in RC, are you sure you want to overwrite?\n", RESET,
	"      (Y)es/(N)o: "
		);
		say q();

		if ($overwrite =~ /\A (?: NO | N )?\z/x) {
			say App::Watson::box_error("Not overwriting current Bitbucket repo info");
			exit 1;
		}
	}

	say for
		box_info("Access to your Bitbucket account required to make/update issues"),
		"      See help or README for more details on GitHub/Bitbucket access",
		q(),
		join(box(BOLD RED q(!)), BOLD "Bitbucket OAuth not implemented yet.", RESET),
		"      Basic HTTP Auth in use, will request PW entry every time.",
		q();

	my $username = App::Watson::prompt(BOLD "Username: ", RESET, {
		default => sub {
			say App::Watson::box_error("Input blank. Please enter your username!");
			exit 1;
		},
	});
	$self->username($username);
	$self->access_token($username);

	my $password = App::Watson::prompt(BOLD "Password: ", RESET, {
		echo => 0,
		default => sub {
			say App::Watson::box_error("Input blank. Please enter your password!");
			exit 1;
		},
	});
	$self->password($password);

	# Get repo information
	# If blank, give error
	say for
		App::Watson::box_info("Repo information required"),
		"      Please provide owner that repo is under followed by repo name",
		"      e.g. owner: nhmood, repo: watson (case sensitive)",
		"      See help or README for more details on GitHub access",
		q();


	my $owner = App::Watson::prompt(BOLD "Owner: ", RESET, {
		default => sub {
			say App::Watson::box_error("Input blank. Please enter the owner the repo is under!");
			exit 1;
		},
	});
	my $repo = App::Watson::prompt(BOLD "Repo: ", RESET, {
		default => sub {
			say App::Watson::box_error("Input blank. Please enter the repo name!");
			exit 1;
		},
	});
	say q();
	$self->repo("$owner/$repo");

	$self->test_access;
	say q();

	Configuration->replace_sections($RCNAME,
		bitbucket     => [$self->access_token],
		bitbucketrepo => [$self->repo],
	);

	say for
	App::Watson::box_ok("Bitbucket successfully setup"),
	"      Issues will now automatically be updated on Bitbucket by default",
	"      Use -l, --local to not update against GitHub",
	"      See help or README for more details on GitHub/Bitbucket access",
	q();

	exit 0;
}

sub App::Watson::Repository::Bitbucket::authorization {
	my $self = shift;
	return $self->{'App::Watson::Repository::Bitbucket/authorization'} //= do {
		'Basic ' . MIME::Base64::encode($self->username . q(:) . $self->password, q());
	};
}

sub App::Watson::Repository::Bitbucket::test_access {
	my $self = shift;

	my $response = App::Watson::UserAgent->get(
		sprintf('https://bitbucket.org/api/1.0/repositories/%s', $self->repo),
		Authorization => $self->authorization,
	);

	if (not $response->is_success) {
		say App::Watson::box_error("Unable to access remote repo with given credentials."),
		say BOLD "Check that credentials are correct and repository exists under owner", RESET;
		exit 1;
	}

	say App::Watson::box_ok("Successfully accessed remote repo with given credentials");
	return 1;
}


###########################################################
# Repository Issue Getter
###########################################################

sub App::Watson::Repository::fetch_issues_ok { ... }
sub App::Watson::Repository::fetch_issues_open_url { ... }
sub App::Watson::Repository::fetch_issues_closed_url { ... }
sub App::Watson::Repository::fetch_issues_extract_issues { ... }

sub App::Watson::Repository::fetch_issues {
	my ($self) = @_;
	my $name = $self->name;

	return unless $self->fetch_issues_ok;

	App::Watson::debug_print("Getting $name Issues\n");

	my $response = App::Watson::UserAgent->get(
		$self->fetch_issues_open_url,
		Authorization => $self->authorization,
	);

	if (not $response->is_success) {
		$self->valid(0);
		print App::Watson::box(BOLD RED "x");
		App::Watson::wprint("--> ", RESET);
		App::Watson::wprint(BOLD "Unable to access remote, $name settings may be invalid\n");
		App::Watson::wprint(BOLD "          Consider running --remote (-r) option to regenerate settings\n\n", RESET);
		return;
	}

	$self->valid(1);
	$self->open_issues->add($_) for
		$self->fetch_issues_extract_issues($response->json);
	App::Watson::debug_print(Data::Dumper::Dump($self->open_issues));

	$response = App::Watson::UserAgent->get(
		$self->fetch_issues_closed_url,
		Authorization => $self->authorization,
	);

	if (not $response->is_success) {
		$self->valid(0);
		say App::Watson::box_warn("Could not get closed issues on $name, ignoring.");
		return;
	}

	$self->closed_issues->add($_) for
		$self->fetch_issues_extract_issues($response->json);
	App::Watson::debug_print(Data::Dumper::Dump($self->closed_issues));

	return;
}

# GitHub Implementation

sub App::Watson::Repository::GitHub::fetch_issues_ok {
	my $self = shift;

	return 1 if defined $self->access_token;
	debug_print("No GitHub access token, ignoring issue list\n");
	return;
}

sub App::Watson::Repository::GitHub::fetch_issues_open_url {
	my $self = shift;

	return sprintf 'https://api.github.com/repos/%s/issues?labels=watson&state=open', $self->repo;
}

sub App::Watson::Repository::GitHub::fetch_issues_closed_url {
	my $self = shift;

	return
	sprintf 'https://api.github.com/repos/%s/issues?labels=watson&state=closed', $self->repo;
}

sub App::Watson::Repository::GitHub::fetch_issues_extract_issues {
	my ($self, $data) = @_;

	return
		grep { defined $_ }
		map  { App::Watson::Issue->reconstruct(@$_{qw<title body>}) }
		@$data;
}

# Bitbucket Implementation

sub App::Watson::Repository::Bitbucket::fetch_issues_ok {
	my $self = shift;

	return 1 if defined $self->repo;
	App::Watson::debug_print("No Bitbucket Repo, ignoring issue list\n");
	return;
}

sub App::Watson::Repository::Bitbucket::fetch_issues_open_url {
	my $self = shift;

	return sprintf 'https://bitbucket.org/api/1.0/repositories/%s/issues', $self->repo;
}

sub App::Watson::Repository::Bitbucket::fetch_issues_closed_url {
	my $self = shift;

	return sprintf 'https://bitbucket.org/api/1.0/repositories/%s/issues?status=resolved', $self->repo;
}

sub App::Watson::Repository::Bitbucket::fetch_issues_extract_issues {
	my ($self, $data) = @_;

	return
		grep { defined $_ }
		map  { App::Watson::Issue->reconstruct(@$_{qw<title content>}) }
		@{ $data->{issues} };
}

BEGIN {
	package App::Watson::IssueList;

	sub new {
		my ($class) = @_;
		return bless {
			__PACKAGE__ . '/contains' => {},
			__PACKAGE__ . '/all' => [],
		} => $class;
	}

	sub add {
		my ($self, $issue) = @_;
		push @{ $self->{__PACKAGE__ . '/all'} }, $issue;
		$self->{__PACKAGE__ . '/contains'}->{$issue->md5} = $issue;
		return $self;
	}

	sub all {
		my $self = shift;
		return @{ $self->{__PACKAGE__ . '/all'} };
	}

	sub contains {
		my ($self, $digest) = @_;
		return $self->{__PACKAGE__ . '/contains'}->{$digest};
	}
}


##########################
# Repository Issue Poster
##########################

sub App::Watson::Repository::post_issue_url { ... }
sub App::Watson::Repository::post_issue_headers {
	return ();
}

sub App::Watson::Repository::post_issue {
	my ($self, $_issue) = @_;
	my $url     = $self->post_issue_url;
	my %headers = $self->post_issue_headers;

	return unless defined $self->access_token;

	my $issue = App::Watson::Issue->new(
		path => $_issue->{file},
		line => $_issue->{linenumber},
		tag  => $_issue->{tag},
		comment => $_issue->{comment},
	);

	# Check if md5 of issue has already been posted
	# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
	return if $self->open_issues->contains($issue->md5);
	return if $self->closed_issues->contains($issue->md5);

	# [todo] - figure out it the formatting actually works as expected
	my $response = App::Watson::UserAgent->post(
		$url,
		Authorization => $self->authorization,
		Content => {
			title   => $issue->title,
			content => $issue->formatted_data,
		},
		%headers,
	);

	if (not $response->is_success) {
		# [todo] - better error handling
		return;
	}

	App::Watson::debug_print($response->decoded_content);

	return;
}

# Github Implementation

sub App::Watson::Repository::GitHub::post_issue_url {
	my ($self) = @_;
	return sprintf 'https://api.github.com/repos/%s/issues', $self->repo;
}

sub App::Watson::Repository::GitHub::post_issue_headers {
	return (JSON => 1);
}

# Bitbucket Implementation

sub App::Watson::Repository::Bitbucket::post_issue_url {
	my ($self) = @_;
	return sprintf 'https://api.github.com/repos/%s/issues', $self->repo;
}


##########################
# Box glyph, e.g [!], [x]
##########################

sub box {
	return join q(), BOLD, "[ ", RESET, @_, RESET, BOLD, " ] ", RESET;
}

# often-used combinations:
sub box_ok    {
	return join q(), box(BOLD GREEN   q(o)), BOLD @_, RESET;
}

sub box_info  {
	return join q(), box(BOLD YELLOW  q(!)), BOLD @_, RESET;
}

sub box_warn  {
	return join q(), box(BOLD MAGENTA q(!)), BOLD @_, RESET;
}

sub box_error {
	return join q(), box(BOLD RED     q(x)), BOLD @_, RESET;
}

#########
# prompt
#########

sub prompt {
	my (@args) = @_;
	my %kw_args;
	if (ref $args[0] eq 'HASH') {
		%kw_args = %{ shift @args };
	}
	elsif (ref $args[-1] eq 'HASH') {
		%kw_args = %{ pop @args };
	}

	my %config = (
		out => select(),
		in	=> \*STDIN,
		echo => 1,
		%kw_args,
	);

	# printflush prints the data, then flushes immediately
	$config{out}->printflush(@args);
	system 'stty', '-echo' unless $config{echo};
	chomp(my $answer = readline $config{in});
	system 'stty', 'echo'  unless $config{echo};
	if (exists $config{default} and not length $answer) {
		return $config{default}->() if ref $config{default} eq 'CODE';
		return $config{default};
	}
	return $config{default} if exists $config{default} and not length $answer;
	return $answer;
}

# kate: space-indent off; indent-width 4; mixedindent off; indent-mode cstyle;
