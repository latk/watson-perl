#!/usr/bin/perl
package Watson;
# watson - inline issue manager
# nhmood @ [goosecode labs] | 2012
# Copyright (c) 2012-2013 goosecode labs
# This content is licensed under the MIT License
# See the file LICENSE for copying permission


# [todo] - add priority listing for tags and todo
# [todo] - generate .html file with report
# [todo] - add text editor/jump to code for each item in .html report
# [todo] - if x is placed in todo [!] then move it to separate file
# [todo] - store in separate file or parse every time? (thinking parse)
# [todo] - tell when directory changes with some header
# [todo] - change @IGNOREDIR to hash instead of array for efficiency
# [todo] - only allow user to check executing users files (setuid exploit)
# [todo] - wrap printed lines around 80 characters
# [todo] - command line option to remove remote repos
# [todo] - replace json parser with just grep? need to get status if failed
# [todo] - add ability to update issue if same title but different md5
# [todo] - implement local only reporting (make it default?)
# [todo] - progress bar for obtaining github/bitbucket issue list
# [todo] - local should be default, must use -r or remote flag to post and check?
#		 - maybe have it check against background unless -local is passed
#		 - but dont post unless --post is used (make it faster?)
# [todo] - add status indicator for remote requests
#		 - we know # of requests and which we are on, can do it that way
# [todo] - change github issue checks to -d instead of issue?key=val
# [todo] - add remote / local options and necessary logic
# [todo] - replace open/closed issue var with just all and closed?

###########################################################
# Global parameters
###########################################################

use strict;
use feature qw/say/;  # implies dependency on perl 5.010
use autodie; # in Core since 5.010
use warnings;

# For color print outs
use Term::ANSIColor qw(:constants);

# Route Ctrl-C to cExit to clean up results
$SIG{'INT'} = \&cExit;

# For debugging (print data structures)
use Data::Dumper;

# For MD5 Sum (issue posting check)
use Digest::MD5 qw(md5_hex);

use JSON ();  # [todo] - list JSON as external dependency
use LWP::UserAgent ();  # [todo] - list LWP::UserAgent as external dependency

use File::Copy ();   # in Core since 5.002
use MIME::Base64 (); # in Core since 5.007.003
use Carp ();         # in Core since 5.000
use Encode ();       # in Core since 5.007.003

# App Config
our $DEBUG = $ENV{WATSON_DEBUG};
our $RCNAME = ".watsonrc";		# Change config file name
our $TMPOUT = ".watsonresults";	# Change tmp file name

# Global variables
my @DIRS;
my @FILES;
my @TAGS;
my @IGNORE;
my @STRUCTURE;
our $REMOTESETUP = 0;
our $MAX_DEPTH = 0;
our $IGNORE_RC_DIRS = 0;
our $IGNORE_RC_FILES = 0;
our $IGNORE_RC_TAGS = 0;
our $IGNORE_RC_IGNORE = 0;
our $HASLESS = 0;
our $HASCURL = 0;
our $LESSOUT;

our $GITHUB    = Watson::Repository::GitHub->new;
our $BITBUCKET = Watson::Repository::Bitbucket->new;

my %REPOSITORIES = (
	github    => $GITHUB,
	bitbucket => $BITBUCKET,
);


#----------------------------------------------------------
###########################################################
# Main Program
###########################################################
#----------------------------------------------------------

checkLess();
checkcURL();
printHeader();
parseCommandLine();
checkConfig();
parseConfig();
startScan();
createReport();


#----------------------------------------------------------
###########################################################
# Functions
###########################################################
#----------------------------------------------------------


###########################################################
# Header Print
###########################################################

# Print watson header
sub printHeader {
	wprint(BOLD "------------------------------\n");
	wprint(BOLD "watson", RESET);
	wprint(" - ");
	wprint(BOLD YELLOW "inline issue manager\n\n", RESET);
	my $pwd = `pwd`;
	wprint("Run in: $pwd");
	my $time = localtime;
	wprint("Run @ $time\n");
	wprint(BOLD "------------------------------\n\n");
	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub printHelp {
	print BOLD, <<'END_HELP', RESET;
Usage: watson [OPTION]...
Running watson with no arguments will parse with settings in RC file
If no RC file exists, default RC file will be created

   -d, --dirs			list of directories to search in
   -f, --files			list of files to search in
   -h, --help			say help
   -i, --ignore			list of files, directories, or types to ignore
   -p, --parse-depth		depth to recursively parse directories
   -r, --remote			list / create tokens for Bitbucket/Github
   -t, --tags			list of tags to search for
   -v, --version		say watson version and info

Any number of files, tags, dirs, and ignores can be listed after flag
Ignored files should be space separated
To use *.filetype identifier, encapsulate in \"\" to avoid shell substitutions


Report bugs to: watson\@goosecode.com
watson home page: <http://goosecode.com/projects/watson>
[goosecode] labs | 2012-2013";
END_HELP

	return 1;
}


###########################################################
# Help Print
###########################################################

# Print watson help
sub printVersion {
	print <<'END_VERSION';
watson v1.3
Copyright (c) 2012-2013 goosecode labs
Licensed under MIT, see LICENSE for details

Written by nhmood, see <http://goosecode.com/projects/watson>
END_VERSION

	return 1;
}


###########################################################
# Clean Exit
###########################################################

# Clean exit function that removes temp files
sub cExit {
	my ($exit_status) = @_;

	unlink $TMPOUT or warn "Could not remove $TMPOUT: $!";

	# If exit status is INT(terupt), set to 1 and print newline
	if ($exit_status eq "INT"){
		$exit_status = 1;
		print "\n";
	}
	exit $exit_status;
}


###########################################################
# Debug Print
###########################################################

# Debug print statements that are only enabled
# when debug flag is set (top of file)
sub debugPrint {
	print @_ if $DEBUG;
}


###########################################################
# Output Print
###########################################################

# If system has less, dump all output to .tmp file and use less
# If no less, just print straight to stdout
sub wprint {
	if ($HASLESS){
		print $LESSOUT @_;
		return 1;
	}
	else {
		print @_;
		return 0;
	}
}


###########################################################
# Unix less Checker
###########################################################

# Check to see if system has less
# If so, set flag and open tmp file
sub checkLess {
	return $HASLESS if defined $HASLESS;
	$HASLESS //= !system("which less > /dev/null 2>&1") or return 0;
	open $LESSOUT, "+>", $TMPOUT;
	return 1;
}


###########################################################
# cURL Checker
###########################################################

# Check to see if system has cURL
# If so, set flag
sub checkcURL {
	return $HASCURL //= !system("which curl > /dev/null 2>&1");
}


###########################################################
# Directory checker
###########################################################

# checkDir - checks if directory can be opened
# Different from just using -d, checks if able to OPEN
sub checkDir {
	my ($dir) = @_;

	# Error check for input
	unless (length $dir) {
		wprint("No directories specified.\n");
		return 0;
	}

	# Check if directory can be opened
	opendir my $tDIR, $dir or do {
		wprint(qq{Cannot open dir "$dir": $!\n});
		return 0;
	};

	closedir $tDIR;
	debugPrint(qq{"$dir" exists and opened successfully.\n});
	return 1;
}


###########################################################
# File checker
###########################################################

# checkFile - checks if file can be opened
# Different from just using -f, checks if able to OPEN
sub checkFile {
	my ($file) = @_;

	# Error check for input
	unless (length $file) {
		wprint("No file specified.\n");
		return 0;
	}

	# Check if file can be opened
	open my $tFILE, $file or do {
		wprint(qq{Could not open "$file": $!\n});
		return 0;
	};

	close $tFILE;
	debugPrint(qq{"$file"" exists and opened successfully.\n});
	return 1;
}


###########################################################
# Config file check
###########################################################

# Check for config file in same dir as watson
# If it doesn't exist, create the default one
sub checkConfig {
	# Should have individual .rc for each dir that watson is in
	# This allows you to keep different preferences for different projects

	# Check for rc
	debugPrint("[Checking for $RCNAME]\n");
	if (-e $RCNAME) {
		debugPrint("$RCNAME found\n\n");
		return 1;
	}
	else {
		debugPrint("$RCNAME not found!\n");
		debugPrint("Creating default $RCNAME\n");

		# Create default rc
		createRC($RCNAME);
		return 0;
	}
}


###########################################################
# Default config file writer
###########################################################

# Create default RC file with some generic settings
sub createRC {
	my ($file_name) = @_;
	open my $file, "+>>", $file_name;

# [fixme] - Figure out a way to indent this?
my $rcdefault = <<'EOF';
# watson rc
# watson - inline issue manager
# [goosecode] labs / 2012


# Directories
[dirs]
./


# Tags
[tags]
fix
review
todo


# Ignores
[ignore]
.git
.swp
EOF

	debugPrint($rcdefault);
	# Print default rc above to specified file
	my $success = print $file $rcdefault;
	close($file);
	return $success;
}


###########################################################
# Command line parser
###########################################################

# Parse command line arguments
sub parseCommandLine {
	debugPrint("[Checking CL args]\n");
	debugPrint("Total args: ", $#ARGV + 1, "\n");

	my %long_opts = (
		"-d" => "--dirs",
		"-f" => "--files",
		"-h" => "--help",
		"-v" => "--version",
		"-t" => "--tags",
		"-p" => "--parse-depth",
		"-i" => "--ignore",
		"-r" => "--remote",
		"-u" => "--update"
	);
	my %opts;
	@opts{%long_opts} = ();

	my $slurp_items = sub {
		my ($cb) = @_;
		my $count = 0;

		# Keep checking following options until another flag or end
		while (@ARGV) {
			if (exists $opts{$ARGV[0]}) {
				debugPrint("Found a flag: $ARGV[0]\n");
				last;
			}

			my $item = shift @ARGV;
			$cb->($item);
		}
	};

	my %flag_actions = (
		'--help' => sub {
			debugPrint("Help flag passed\n");
			printHelp();
			cExit(0);
		},
		'--version' => sub {
			debugPrint("Version flag passed\n");
			printVersion();
			cExit(0);
		},
		'--parse-depth' => sub {
			debugPrint("Parse Depth flag passed\n");
			# Check to make sure next param is a valid number (non-negative)

			unless (@ARGV) {
				wprint(box(BOLD RED "x"), "--parse-depth requires a numeric argument\n");
			}

			my $depth = shift @ARGV;

			if ($depth =~ /[^0-9]/) {
				wprint(box(BOLD MAGENTA "!"));
				wprint("--> ", RESET);
				wprint("Invalid parse depth passed\n");
				return;
			}

			$MAX_DEPTH = $depth;
			debugPrint("Valid parse depth: $MAX_DEPTH\n");
		},
		'--remote' => sub {
			debugPrint("Remote Flag passed\n");

			# When generating OAuth Token for github/bitbucket
			# no other params should be passed
			if (@ARGV > 1){
				debugPrint("Not the only flag, exiting\n");
				print box(BOLD RED "x");
				print "Please run remote flag alone to generate GitHub/Bitbucket OAuth token\n";
				print "      See help for more details\n";
				cExit(1);
			}

			# Can only do this if we have cURL on the system
			unless ($HASCURL) {
				print box(BOLD RED "x");
				print "It looks like you don't have cURL\n";
				print "      We currently only support remote issues if you have cURL\n";
				print "      Make sure cURL is installed and in your PATH\n";
				cExit(1);
			}

			my $service = lc shift @ARGV;

			if ($service eq "bitbucket") {
				bitbucketSetup();
			}
			elsif ($service eq "github") {
				$GITHUB->setup;
			}
			elsif ($service eq "") {
				parseConfig() if checkConfig();

				if (not defined $BITBUCKET->api and not defined $GITHUB->api) {
					say box_error("No remotes currently exist");
					say BOLD "      Pass github or bitbucket to watson -r to add", RESET;
					say "      That's all we support right now :(";
					say "      See help for more details";
					cExit(1);
				}

				if (defined $BITBUCKET->api) {
					print box(BOLD GREEN "Bitbucket"), "\n";
					say BOLD "   Bitbucket User :", RESET, " ", $BITBUCKET->api;
					say BOLD "   Bitbucket Repo :", RESET, " ", $BITBUCKET->repo;
					say "";
				}

				if (defined $GITHUB->api) {
					say box(BOLD GREEN "GitHub");
					say BOLD "   GitHub Key  :", RESET, " ", $GITHUB->api;
					say BOLD "   GitHub Repo :", RESET, " ", $GITHUB->repo;
					say "";
				}

				cExit(1);
			}
			else {
				say box_error("Incorrect argument");
				say for
					"      Please specify either github or bitbucket to setup remote",
					"      Or pass without argument to see current remotes",
					"      See help for more details";
				cExit(1);
			}
		},
		'--dirs' => sub {
			debugPrint("Dir flag passed\n");
			$slurp_items->(sub {
				my ($dir) = @_;
				debugPrint("Dir Index: $dir\n");

				if (checkDir($dir)) {
					debugPrint("dirflag: {$dir} valid directory, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debugPrint("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC_DIRS = 1;

					# Remove trailing slashes
					$dir =~ s{/+\z}{};
					push @DIRS, $dir;
				}
			});
		},
		'--files' => sub {
			debugPrint("File flag passed\n");
			$slurp_items->(sub {
				my ($file) = @_;
				debugPrint("File Index: $file\n");

				if (checkFile($file)) {
					debugPrint("fileflag: {$file} valid file, added from CL.\n");

					# If we ever get into this, means CL passed
					# Set RC ignore so we don't look at rc
					debugPrint("Ignoring RC Files/Dirs\n\n");
					$IGNORE_RC_FILES = 1;

					push @FILES, $file;
					}
			});
		},
		'--tags' => sub {
			debugPrint("Tag flag passed\n");
			$slurp_items->(sub {
				my ($tag) = @_;
				debugPrint("Tag Index: $tag\n");
				debugPrint("tagflag: {$tag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debugPrint("Ignoring RC tags\n\n");
				$IGNORE_RC_TAGS = 1;

				push @TAGS, $tag;
			});
		},
		'--ignore' => sub {
			debugPrint("Tag flag passed\n");
			$slurp_items->(sub {
				my ($ignoreflag) = @_;
				debugPrint("Ignore Index: $ignoreflag\n");
				debugPrint("ignoreflag: {$ignoreflag} added from CL.\n");

				# If we ever get into this, means CL passed
				# Set RC ignore so we don't look at rc
				debugPrint("Ignoring RC ignore\n\n");
				$IGNORE_RC_IGNORE = 1;

				push @IGNORE, $ignoreflag;
			});
		},
	);
	for my $key (keys %long_opts) {
		$flag_actions{$key} = $flag_actions{$long_opts{$key}};
		exists $flag_actions{$key}
			or warn "The option $long_opts{$key} is not implemented";
	}

	unless (@ARGV) {
		debugPrint("No command line arguments passed.\n\n");
		return;
	}

	while (@ARGV) {
		my $item = shift @ARGV;
		debugPrint("Main Item: $item\n");

		if (my $action = $flag_actions{$item}) {
			$action->();
		}
		else {
			die qq{Can't understand command line argument "$item"};
		}
	}
	return 1;
}


###########################################################
# Config file parser
###########################################################

BEGIN {
	package Watson::Configuration;

	sub new_from_file {
		my ($class, $filename) = @_;
		open my $fh, "<", $filename;

		my %sections;

		my $section;
		while (<$fh>) {
			chomp;
			Watson::debugPrint("# line $.: $_\n");

			next if !/\S/;
			next if /\A\s*#/;

			if (/\A\[(\w+)\]\s*\z/) {
				$section = lc $1;
				Watson::debugPrint("# recognized as section [$section]\n");
				next;
			}

			die qq/No section specified at "$filename" line $../
				unless defined $section;

			push @{ $sections{$section} }, $_;
			Watson::debugPrint("# added to [$section]\n");
		}

		return bless {
			sections => \%sections,
		} => $class;
	}

	sub sections {
		my $self = shift;
		return $self->{sections};
	}

	sub section {
		my $self = shift;
		Carp::croak qq/Argument "name" is required/ unless @_;
		my $name = shift;
		Carp::croak "name must be defined" unless defined $name;
		return $self->{sections}{$name} if exists $self->{sections}{$name};
		return my $default = shift if @_;
		Carp::croak qq/No entry for "$name" present, and no default given/;
	}

	sub section_names {
		my $self = shift;
		return keys %{ $self->{sections} };
	}

	sub replace_sections {
		my (undef, $filename, %replacements) = @_;

		# First, delete the old sections if applicable:

		my $nlc = 0;
		if (Watson::checkConfig()){
			open my $in,  "<", $filename;
			open my $out, ">", "$filename.new";

			my $section = "";
			while (<$in>){
				chomp;
				$section = lc $1 if /^\[(\w+)\]/;

				# Max 2 consecutive empty lines
				if (!/\S/ and ++$nlc <= 2) {
					say $out "";
					next;
				}

				next if exists $replacements{$section};

				# This section won't be changed - copy everything over.
				say $out $_;
				$nlc = 0;  # Reset newline count
			}

			# Remove old RC file and replace with new one
			File::Copy::move("$filename.new" => $filename)
				or die qq{Can't move update RC at "$filename": $!};
		}

		# Now, append the new sections to the file (new or old, doesn't matter)

		open my $file, ">>", $filename;


		for my $section (sort keys %replacements) {
			# print remaining newlines
			say $file "" for $nlc .. 1;

			say $file "[$section]";
			say $file $_ for @{ $replacements{$section} };

			$nlc = 0;
		}
		close $file;
	}
}

# Go through config file and determine dirs, tags, and ignores to use
sub parseConfig {
	# Parse rc
	debugPrint("Parsing $RCNAME\n");

	# Add . and .. and .git to ignorelist
	push @IGNORE, ".", "..", "*.swp", ".watsonrc", $TMPOUT;

	my %actions = (
		# If @DIRS or @FILES wasn't populated by CL args, populate from rc
		dirs => sub {
			my $name = shift;
			if ($IGNORE_RC_DIRS || $IGNORE_RC_FILES) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for dirs, then push to @DIRS
				$line =~ m{\A\s* ((?:\.?/?\w?+/?)+) \s*\z}x
					or die qq{The line "$line" in a "dirs" section did not contain a valid path};
				(my $dir = $1) =~ s{/+\z}{};
				debugPrint("dirs: $dir added from rc. \n");
				push @DIRS, $dir;
			}
		},
		# If @TAGS wasn't populated by CL args, populate from rc
		tags => sub {
			my $name = shift;
			if ($IGNORE_RC_TAGS) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for tags, then push to @TAGS
				$line =~ /^\A\s* (\w+(?: \| [0-9])?) \s*\z/x
					or die qq{The line "$line" in a "tags" section did not contain a valid tag};
				my $tag = $1;
				debugPrint("tags: $tag added from rc.\n");
				push @TAGS, $tag;
			}
		},
		# If @IGNORE wasn't populated by CL args, populate from rc
		ignore => sub {
			my $name = shift;
			my ($line) = @_;
			if ($IGNORE_RC_IGNORE) {
				debugPrint("Directories set from command line, ignoring rc [dirs]!\n");
				return;
			}

			for my $line (@_) {
				# Regex for dirs to ignore, then push to @IGNOREDIR
				$line =~ m{\A\s* (.+) \s*\z}x
					or die qq{The line "$line" in a "ignore" section did not contain a valid path};
				(my $path = $1) =~ s{(/)+\z}{};
				debugPrint("ignore: $path added from rc.\n");
				push @IGNORE, $path;
			}
		},
		github => sub {
			my $name = shift;
			my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

			for my $api (@_) {
				say box_warn("The ", $repository->name, " API was already set, overwriting")
					if defined $repository->access_token;

				# No need for regex on API key
				debugPrint($repository->name . "API: $api\n");
				$repository->access_token($api);
			}
		},
		githubrepo => sub {
			my $name = shift;
			$name =~ s/repo\z//;
			my $repository = $REPOSITORIES{$name} or die "Unknown service $name";

			for my $repo (@_) {
				say box_warn("The ", $repository->name, "Repo was already set, overwriting")
					if defined $repository->repo;

				# No need for regex on repo
				debugPrint($repository->name . "Repo: $repo\n");
				$repository->repo($repo);
			}

			# If setting up remote, don't ask for password / do any remote stuff
			# Won't need this when OAuth implemented but it does optimize the code...

			# Get list of issues, also checks if API key is valid
			unless ($REMOTESETUP) {
				getGithubIssues()    if $repository == $GITHUB;
				getBitbucketIssues() if $repository == $BITBUCKET;
			}
		},
	);
	$actions{bitbucket}     = $actions{github};
	$actions{bitbucketrepo} = $actions{githubrepo};

	my $config = Watson::Configuration->new_from_file($RCNAME);

	for my $section ($config->section_names) {
		my $action = $actions{$section} or die qq/Unknown section "$section"/;
		debugPrint("[$section] contains [@{[$config->section($section)]}]\n");
		$action->($section => $_) for @{ $config->section($section) };
	}

	return 1;
}


###########################################################
# File/Folder Parser Wrapper
###########################################################

# Start going through all files and subdirs of specified folder
sub startScan{

	# If files passed to command line, push those to structure
	# Have to populate structure this way to print properly
	if ($IGNORE_RC_FILES){
		# For each file obtained from CL (if any) parse file
		# Create proper structure for files so we can push to @STRUCTURE
		push @STRUCTURE, {
			files => [ map { parseFile($_) } @FILES ],
		};
	}

	# For each directory obtained from rc or CL, look for files in them
	# This will always be valid, not condition like files above
	push @STRUCTURE, map { parseDirs($_) } @DIRS;

	wprint("\n");
	return 1;
}


###########################################################
# Directory Parser
###########################################################

# Look through directory for files to parse
sub parseDirs {
	my ($dir, $depth) = @_;
	$depth //= 1;
	return if $MAX_DEPTH and $depth > $MAX_DEPTH;
	debugPrint("parseDirs: |$dir| at depth $depth/$MAX_DEPTH\n");
	return unless checkDir($dir); # Error check for input

	my @pdirs;		# subdirectories found
	my @pfiles;		# files found

	# Loop through all entries in directory
	debugPrint(qq{Looping through all files/folders in "$dir"\n});

	# Open dir and get list of all files
	opendir(my $wd, $dir);
	ENTRY: for my $entry (sort grep !/\A\.\.?\z/, readdir $wd) {
		# Combine dir and entry to make full path
		my $path = "$dir/$entry";

		debugPrint("path: |$path|\n");

		# Make sure it isn't part of ignored list
		# If it is, set to "", won't pass dir/file check
		# [reviewme] - Should we warn users when file is ignored on stdout?
		for my $ignore (@IGNORE){
			# Check for any *.type in ignore list (list .swp)
			# Regex to see if extension is .type, ignore if so
			($ignore) = map qr/\A$_\z/, join '.*', map quotemeta, split /[*]/, $ignore
				unless ref $ignore;
			if ($entry =~ /$ignore/) {
				debugPrint("|$path| is on the ignore list, skipping\n");
				next ENTRY;
			}
		}

		# Check if entry is a file, if so parse
		if (-f $path) {
			debugPrint("|$path| is a file!\n");
			push @pfiles, parseFile($path);
		}
		# Check if entry is dir, if so parse
		elsif (-d $path) {
			debugPrint("|$path| is a dir!\n");
			push @pdirs, parseDirs($path, $depth + 1);
		}

		# Add directory to ignore list so it isn't repeated again
		push @IGNORE, $path;
	}

	closedir $wd;
	# Create has to hold all parsed files and folders
	return {
		files => \@pfiles,
		dirs => \@pdirs,
	};
}


###########################################################
# File Parser
###########################################################

sub parseFile {
	# [fixme] - need a better check for valid files (when using @_)
	my ($file) = @_;
	debugPrint("parseFile: |$file|\n");

	# Error check for input
	return unless checkFile($file);

	# Get filetype and set corresponding comment type
	my $comment = getComment($file);

	# Open file and seek to beginning
	open my $wf, "<", $file;
	seek $wf, 0, 0;

	my %issueList = (
		filename => $file,
		(map { $_ => [] } @TAGS),
	);

	# Read source file line by line
	while (my $line = <$wf>){
	    # Find any comment line with [tag] - text (any comb of space and #)
	    if ($line =~ /\s*(?:$comment)+\s*\[(\S+)\]\s*-\s*(.+)/) {
			my ($ftag, $fissue) = ($1, $2);
			debugPrint("Issue found!\n");
			debugPrint("Tag: $ftag\n");
			debugPrint("Issue: $fissue\n");

			next unless exists $issueList{$ftag};

			# Create hash for each issue found (for each tag)
			my %issue = (
				linenumber => $.,
				comment => $fissue,
				tag => $ftag,
				file => $file,
			);

			# Create hash for specific issue
			my $digest = md5_hex(@issue{qw/tag file comment/});
			debugPrint("$digest\n");
			$issue{md5} = $digest;

			push @{$issueList{$ftag}}, \%issue;

			# If Github valid, pass $issue to poster function
			postGithub(\%issue) if $GITHUB->valid;

			# If Bitbucket valid, pass $issue to poster function
			postBitbucket(\%issue) if $BITBUCKET->valid;
	    }
	}

	return \%issueList;
}


###########################################################
# Comment setter
###########################################################

# Determine comment type from file extension
sub getComment {
	my ($file) = @_;
	debugPrint("Getting comment type\n");

	# Grab the ending extension (.something)
	# Check to see whether it is recognized and set comment type
	# If unrecognized, try to grab next .something extension
	# This is to account for file.cpp.1 or file.cpp.bak, ect

	my %exts;
	$exts{$_} = qr{//} for qw/cpp cc c h c++/; # [todo] - add /* style comment
	$exts{$_} = qr{#}  for qw/sh rb pl pm/;

	my (undef, @extensions) = grep !/\s/, split /\./, $file;
	for my $ext (reverse @extensions) {
		# Regex for last extension
		debugPrint("Extension: $ext\n");
		return $exts{$ext} // next;
	}

	print box(BOLD MAGENTA "!");
	print("--> ", RESET);
	print("Couldn't determine filetype for $file, using # as comment\n", RESET);

	# Didn't find any match, return error (and just use #)
	return qr{#};
}


###########################################################
# Result Printer Wrapper
###########################################################

# Format the parsed file data and output it nicely
sub createReport {
	# Display output for each file parsed
	for my $entry (@STRUCTURE){
		printResults($entry);
	}

	if ($HASLESS){
		system("less -R $TMPOUT");
		close($LESSOUT);
		system("rm $TMPOUT > /dev/null 2>&1");
	}
	return 1;
}


###########################################################
# Individual Result Printer
###########################################################

# Print results from parsing all pretty and stuff
sub printResults {
	my ($entry) = @_;
	# Go through and print info for all files first
	for my $file_report (@{$entry->{files}}) {

		# [fixme] - Same foreach performed below, combine somehow?

		# Go through and see if there are any issues with given file
		# Sets print color and whether to continue to print
		my $issueflag = grep { 0+@{$file_report->{$_}} } @TAGS;

		if ($issueflag){
			wprint("\n");
			wprint(box_error(UNDERLINE $file_report->{filename}), "\n");
		}
		else {
			wprint(box_ok(UNDERLINE $file_report->{filename}), "\n");
		}

		# If there are no issues, don't print anything (go to next file)
		# Else, continue on and print the issues
		next unless $issueflag;

		# Cycle through all tags and print issues for each
		for my $tag (@TAGS){
			my @issues = @{$file_report->{$tag}} or next;

			# Print tag, line #, and issue
			wprint(box(BOLD BLUE $tag), "\n");

			for my $issue (@issues) {
				wprint(WHITE "  line $issue->{linenumber} - ", RESET, BOLD "$issue->{comment} ", RESET);

				# If valid API key
				# Check if issue has been closed on Github or Bitbucket, set to resolved
				wprint(box(BOLD GREEN "Resolved on GitHub"))
					if	$GITHUB->valid
					and	$GITHUB->closed_issues =~ m/$issue->{md5}/;

				wprint(box(BOLD GREEN "Resolved on Bitbucket"))
					if 	$BITBUCKET->valid
					and	$BITBUCKET->closed_issues =~ m/$issue->{md5}/;

				wprint("\n");
			}
			wprint("\n");
		}
	}

	printResults($_) for @{$entry->{dirs}};

	return 1;
}

#####################
# Repository Classes
#####################

BEGIN {
	package Watson::Repository;

	my %prototype = (
		valid	=> 0,
		access_token	=> undef,
		pw	=> undef,
		repo	=> undef,
		open_issues => undef,
		closed_issues => undef,
	);
	my @other_fields = qw/user_agent/;

	sub new {
		my ($class, %args) = @_;

		if ($class eq __PACKAGE__) {
			Carp::croak "This class is abstract and should not be instantiated";
		}

		my $self = {%prototype};
		for my $field (grep { exists $args{$_} } @other_fields, keys %prototype) {
			$self->{__PACKAGE__ . '/' . $field} = delete $args{$field};
		}

		if (keys %args) {
			Carp::croak "Unknown constructor arguments [@{[join ', ', keys %args]}]";
		}

		return bless $self => $class;
	}

	# a bit of meta-programming: writing the accessors
	for my $field (keys %prototype) {
		no strict 'refs';
		*{ $field } = sub {
			my $self = shift;
			return $self->{__PACKAGE__ . '/' . $field} = shift if @_;
			return $self->{__PACKAGE__ . '/' . $field};
		}
	}

	sub name { ... }

	*api = \&access_token;

	sub user_agent {
		my $self = shift;
		return $self->{__PACKAGE__ . '/user_agent'} = shift if @_;
		return $self->{__PACKAGE__ . '/user_agent'} //= LWP::UserAgent->new;
	}

	package Watson::Repository::GitHub;
	use parent -norequire, 'Watson::Repository';

	sub name { "GitHub" }

	package Watson::Repository::Bitbucket;
	use parent -norequire, 'Watson::Repository';

	sub name { "Bitbucket" }
}


###########################################################
# GitHub Setup
###########################################################

# Obtain API key for either Github
sub Watson::Repository::GitHub::setup {
	my $self = shift;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print box(BOLD GREEN "+");
	print BOLD "Obtaining OAuth Token for GitHub...\n", RESET;

	# Parse config to make sure no previous API exists
	Watson::parseConfig() if Watson::checkConfig();

	if (defined $self->api or defined $self->repo) {
		my $overwrite = uc prompt(
			{ default => "N" },
			box(BOLD RED "!"),
			BOLD "Previous GitHub API + Repo is in RC, are you sure you want to overwrite?\n", RESET,
			"      (Y)es/(N)o: ",
		);
		print "\n";

		if ($overwrite =~ /\A(?:NO?)?\z/){
			say box_error("Not overwriting current GitHub API + repo info");
			cExit(1);
		}
	}

	say for
		box_info("Access to your GitHub account required to make/update issues"),
		"      See help or README for more details on GitHub/Bitbucket access",
		"";

	# Get username, clear newlines surrounding text
	# If blank, give error
	my $username = prompt(BOLD "Username: ", RESET);
	unless (length $username) {
		say box_error("Input blank. Please enter your username!");
		cExit(1);
	}

	my $password = prompt({ echo => 0 }, BOLD "Password: ", RESET);
	unless (length $password) {
		say box_error("Input blank. Please enter your password!");
		cExit(1);
	}

	# fetch an access token from GitHub
	$self->fetch_authorization($username, $password);
	say RESET;

	# Get repo information
	# If blank, give error
	say for
		box_info(BOLD "Repo information required"),
		"      Please provide owner that repo is under followed by repo name",
		"      e.g. owner: nhmood, repo: watson (case sensitive)",
		"      See help or README for more details on GitHub access",
		"";

	my $owner = prompt(BOLD "Owner: ", RESET);
	unless (length $owner) {
		say box_error("Input blank. Please enter the owner the repo is under!");
		cExit(1);
	}

	my $repo = prompt(BOLD "Repo: ", RESET);
	unless (length $repo) {
		say box_error("Input blank. Please enter the repo name!");
		cExit(1);
	}
	$self->repo("$owner/$repo");

	# test that the repo can be accessed
	$self->test_access;

	say box_error("Creating label for watson on GitHub...\n");

	# Create label for watson
	my $response = $self->user_agent->post(
		sprintf('https://api.github.com/repos/%s/labels', $self->repo),
		Authorization => 'token ' . $self->authorization_token,
		Content => JSON::encode({
			name => "watson",
			color => "00AEEF",
		}),
	);

	# Expected HTTP Status Code: "201 created";
	if ($response->code == 201) {
		say box_ok("Label successfully created");
	}
	elsif ($response->status_line =~ m/already_exists/i) {
		say box_info("Label already exists");
	}
	else {
		say box_error("Unable to access /repo/@{[ $self->repo ]} (HTTP Status @{[ $response->status_line ]})");
		cExit(1);
	}
	say "";

	Configuration->replace_sections($RCNAME,
		github     => $self->access_token,
		githubrepo => $self->repo,
	);

	say for
		box_ok("GitHub successfully setup"),
		"      Issues will now automatically be updated on GitHub by default",
		"      See help or README for more details on GitHub/Bitbucket access",
		"";
	cExit(0);
}

sub Watson::Repository::GitHub::fetch_authorization {
	my ($self, $username, $password) = @_;

	my $ua = $self->user_agent;
	my $authorization = 'Basic ' . MIME::Base64::encode("$username:$password");
	my $response = $ua->post(
		'https://api.github.com/authorizations',
		Authorization => $authorization,
		Content => JSON::encode_json({
			scopes   => [qw[repo]],
			note     => 'watson',
			note_url => 'http://watson.goosecode.com',
		}),
	);

	# Expected Status Code: "201 Created"
	if ($response->code == 201) {
		say box_ok("Obtained OAuth Token");
	}
	else {
		say box_error("Unable to obtain OAuth Token");
		cExit(1);
	}

	my $utf8_encoded_content = Encode::encode('utf8', $response->decoded_content);
	my $dsc = JSON::parse_json($utf8_encoded_content);
	my $access_token = $dsc->{token};

	unless (defined $access_token) {
		Carp::croak "The returned JSON did not contain an access token.\n", Data::Dumper::Dump($dsc);
	}

	$self->access_token($access_token);

	return $access_token;
}


sub Watson::Repository::GitHub::test_access {
	my $self = shift;

	my $response = $self->user_agent->get(
		sprintf('https://api.github.com/repos/%s/issues', $self->repo),
		Authorization => 'token ' . $self->authorization_token,
	);

	unless ($response->is_success) {
		say box_error("Unable to access /repos/@{[ $self->repo ]} (HTTP Status @{[ $response->status_libe ]}).");
		cExit(1);
	}

	say box_ok("Repo successfully accessed");
	return 1;
}


###########################################################
# Github Issue Getter
###########################################################

# Post issues to github/bitbucket
sub getGithubIssues {
	# Only attempt if API is specified
	if (defined $GITHUB->api) {
		debugPrint("Getting GitHub Issues\n");
		# Get open tickets

		my $call = sprintf "curl -s -i -H 'Authorization: token %s' 'https://api.github.com/repos/%s/issues?labels=watson&state=open'", $GITHUB->api, $GITHUB->repo;
		$GITHUB->open_issues(`$call`);
		debugPrint($GITHUB->open_issues);

		# Check or a Status 200 OK, if not, API key might be invalid, warn user
		# Set GITHUB_VALID to 0 so that no remote related calls will be made
		if ($GITHUB->open_issues !~ m/200 OK/){
			$GITHUB->valid(0);
			print box(BOLD RED "x");
			wprint("--> ", RESET);
			wprint(BOLD "Unable to access remote, GitHub API may be invalid\n");
			wprint(BOLD "          Consider running --remote (-r) option to regenerate key\n\n", RESET);
		}
		# Else get the closed tickets also and set GITHUB_VALID to 1
		else {
			$GITHUB->valid(1);
			my $call = sprintf "curl -s -i -H 'Authorization: token %s' 'https://api.github.com/repos/%s/issues?labels=watson&state=closed'", $GITHUB->api, $GITHUB->repo;
			$GITHUB->closed_issues(`$call`);
			debugPrint($GITHUB->closed_issues);
		}
	}
	else {
		debugPrint("No GitHub API, ignoring issue list\n");
	}

}


###########################################################
# Github Issue Poster
###########################################################

# Post issues to github/bitbucket
sub postGithub {
	my ($issue) = @_;
	# If Github API has been registered, post on Github
	return unless length $GITHUB->api;

	# Check if md5 of issue has already been posted
	# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
	return if $GITHUB->open_issues   =~ m/$issue->{md5}/;
	return if $GITHUB->closed_issues =~ m/$issue->{md5}/;

	# Format title and body for creating issue
	# Title format: comment [basename of file], escape any '
	(my $file = $issue->{file}) =~ s{^.+/}{};
	my $title = "$issue->{comment} [$file]";
	# [fixme] - Figure out how to escape ' character on JSON post
	$title =~ s/'//;

	debugPrint("Formatted title for GitHub Post : $title\n");

	# Format comment to escape any ' so JSON will be formatted properly
	my $body = "__filename__ : $issue->{file}\\n" .
				"__line #__ : $issue->{linenumber}\\n" .
				"__tag__ : $issue->{tag}\\n" .
				"__md5__ : $issue->{md5}\\n";
	debugPrint("Formatted body for GitHub Post : $body\n");

	my $call = sprintf qq(curl -s -i -H 'Authorization: token %s' https://api.github.com/repos/%s/issues -d '{"title" : "%s", "body" : "%s", "labels" : [ "watson", "%s"]}'), $GITHUB->api, $GITHUB->repo, $title, $body, $issue->{tag};
	debugPrint("Formatted call for GitHub Post : $call\n");
	my $response = `$call`;
	debugPrint($response);
}


###########################################################
# Bitbucket Setup
###########################################################

# Set up Bitbucket access
# [todo] - Only basic http auth, get OAuth for Bitbucket
# Bitbucket OAuth needs to redirect to some grant access page
# Not sure how to do that with a CLI, basic HTTP auth for now
sub bitbucketSetup {
	# JSON Response var
	my $js;

	# Set remote setup to one so password isn't asked for in Bitbucket parseConfig section
	# Crappy fix, won't need this when OAuth is implemented for Bitbucket
	$REMOTESETUP = 1;

	# [fixme] - Same code as header just without wprint, make modular
	print(BOLD "------------------------------\n");
	print(BOLD "watson", RESET);
	print(" - ");
	print(BOLD YELLOW "inline issue manager\n", RESET);
	print(BOLD "------------------------------\n\n");

	# [fixme] - Make modular status printer?
	print box(BOLD GREEN "+");
	print BOLD "Attempting to access Bitbucket...\n", RESET;;

	# Parse config to make sure no previous API exists
	parseConfig() if checkConfig();

	if (defined $BITBUCKET->api or defined $BITBUCKET->repo){
		my $overwrite = uc prompt(
			{ default => 'N' },
			box(BOLD RED "!"),
			BOLD "Previous Bitbucket Repo is in RC, are you sure you want to overwrite?\n", RESET,
			"      (Y)es/(N)o: "
		);
		print "\n";

		if ($overwrite =~ /\A(?:NO?)?\z/) {
			print box(BOLD RED "x");
			print BOLD "Not overwriting current Bitbucket repo info\n", RESET;
			cExit(1);
		}
	}

	print box(BOLD YELLOW "!");
	print BOLD "Access to your Bitbucket account required to make/update issues\n", RESET;
	print "      See help or README for more details on GitHub/Bitbucket access\n\n";

	print box(BOLD RED "!");
	print BOLD " Bitbucket OAuth not implemented yet.\n", RESET;
	print "      Basic HTTP Auth in use, will request PW entry every time.\n\n";


	# Get username, clear newlines surrounding text
	# If blank, give error
	my $username = prompt(BOLD "Username: ", RESET);
	if ($username eq "") {
		print box(BOLD RED "x");
		print BOLD "Input blank. Please enter your username!\n", RESET;
		cExit(1);
	}

	print "\n";

	# Get repo information
	# If blank, give error
	print box(BOLD YELLOW "!");
	print BOLD "Repo information required\n", RESET;
	print "      Please provide owner that repo is under followed by repo name\n";
	print "      e.g. owner: nhmood, repo: watson (case sensitive)\n";
	print "      See help or README for more details on GitHub access\n\n";


	my $owner = prompt(BOLD "Owner: ", RESET);
	if ($owner eq "") {
		print box(BOLD RED "x");
		print BOLD "Input blank. Please enter the owner the repo is under!\n", RESET;
		cExit(1);
	}
	my $repo = prompt(BOLD "Repo: ", RESET);
	if ($repo eq "") {
		print box(BOLD RED "x");
		print BOLD "Input blank. Please enter the repo name!\n", RESET;
		cExit(1);
	}

	print "\n";

	my $call;
	my $response;

	$call = sprintf "curl -s -i 'https://bitbucket.org/api/1.0/repositories/%s/%s' -u '%s'", $owner, $repo, $username;
	print BOLD;
	$response = `$call`;
	print "\n", RESET;
	# [fixme] - Pretty bad way of doing this, either grep or improve parser
	if ($response =~ m{HTTP/1.1 200 OK}) {
		print box(BOLD GREEN "o");
		print BOLD "Successfully accessed remote repo with given credentials\n";
	}
	else {
		print box(BOLD RED "x");
		print BOLD "Unable to access remote repo with given credentials\n", RESET;
		print BOLD "Check that credentials are correct and repository exists under owner\n", RESET;
		#print "      Status: ", $js->{"Status"}, "\n";
		cExit(1);
	}

	print "\n", RESET;



	# Check if RC exists
	# If it exists, basically replicate it and remove [github/bitbucket tag]
	my $nlc = 0;

	if (checkConfig()){
		debugPrint("Config exists, copying\n");
		open my $in, "<", "$RCNAME";
		open my $out, ">", "$RCNAME.new";
		my $section = "";
		while (my $line = <$in>){
			chomp;
			debugPrint("$line\n");
			$section = lc $1 if $line =~ /^\[(\w+)\]/;


			# Check for newlines
			# If we already have 2 newlines before any actual content, skip
			# This is just to make the RC file output nicer looking
			if (not length $line){
				debugPrint("Newline found\n");
				if (++$nlc < 3){
					debugPrint("Less than 3 newlines so far, let it print\n");
					print $out $line;
				}
			}
			# If not in bitbucket or github section, safe to copy
			# make $remotestr lowercase and check that + repo
			elsif ($section ne "bitbucket"  and $section ne "bitbucketrepo"){
				debugPrint("Not in bitbucket section, copying to new rc\n");
				print $out $line;
				# Reset newline count
				$nlc = 0;
			}

			debugPrint("line: $line");
			debugPrint("nlc: $nlc\n");
		}

		# Remove old RC file and replace with new one
		File::Copy::move("$RCNAME.new" => $RCNAME) or warn qq{Could not update the RC file "$RCNAME": $!};
	}

	# Append API token to end of file (old or new, doesn't matter now)
	open my $file, "+>>", $RCNAME;

	# Make sure there are only 2 newlines between items in RC
	print $file "\n" for $nlc .. 1;

	# Store username in bitbucket api section since we don't OAuth yet
	say $file $_ for
		"[bitbucket]",
		$username,
		"",
		"",
		"[bitbucketrepo]",
		"$owner/$repo",
		"";
	close $file;

	print box(BOLD GREEN "o");
	print BOLD "Bitbucket successfully setup\n", RESET;
	print "      Issues will now automatically be updated on Bitbucket by default\n";
	print "      Use -l, --local to not update against GitHub\n";
	print "      See help or README for more details on GitHub/Bitbucket access\n";
	print "\n";
	cExit(0);
}


###########################################################
# Bitbucket Issue Getter
###########################################################

# Post issues to github/bitbucket
sub getBitbucketIssues {
	# Only attempt if repo is specified
	if (defined $BITBUCKET->repo){
		debugPrint("Getting Bitbucket Issues\n");

		my $pw = prompt(
			{ echo => 0 },
			BOLD "Bitbucket password required for remote checking/posting: ", RESET,
		);
		print "\n";
		if (length $pw) {
			$BITBUCKET->pw($pw);
		}
		else {
			print box(BOLD RED "x");
			print BOLD "Input blank. Will not check/update against Bitbucket\n", RESET;
			$BITBUCKET->pw(undef);
			$BITBUCKET->valid(0);
			return 1;
		}

		# Get all issues, Bitbucket differentiates between open/new so we can just look for all
		# The open issue var is used only for preventing posting again anyways
		# Only need closed ones to update final output, might change in Github too?
		my $call = sprintf "curl -s -i 'https://bitbucket.org/api/1.0/repositories/%s/issues' -u '%s:%s'", $BITBUCKET->repo, $BITBUCKET->api, $pw;
		$BITBUCKET->open_issues(`$call`);
		debugPrint($BITBUCKET->open_issues);

		# Check for a Status
		if ($BITBUCKET->open_issues !~ m/HTTP\/1.1 200 OK/){
			$BITBUCKET->valid(0);
			print box(BOLD RED "x");
			wprint("--> ", RESET);
			wprint(BOLD "Unable to access remote, Bitbucket settings may be invalid\n");
			wprint(BOLD "          Consider running --remote (-r) option to regenerate settings\n\n", RESET);
		}
		# Else get the closed tickets also and set BITBUCKET_VALID to 1
		else {
			$BITBUCKET->valid(1);
			$call = sprintf "curl -s -i 'https://bitbucket.org/api/1.0/repositories/%s/issues?status=resolved' -u '%s:%s'", $BITBUCKET->repo, $BITBUCKET->api, $pw;

			$BITBUCKET->closed_issues(`$call`);
			debugPrint($BITBUCKET->closed_issues);
		}
	}
	else {
		debugPrint("No Bitbucket Repo, ignoring issue list\n");
	}
}


###########################################################
# Bitbucket Issue Poster
###########################################################

# Post issues to github/bitbucket
sub postBitbucket {
	my ($issue) = @_;
	# Bitbucket API has been registered, post on Github
	return unless defined $BITBUCKET->api;
	# Check if md5 of issue has already been posted
	# [fixme] - if issue with same name in same file is made, won't ever get posted again :-/
	return if $BITBUCKET->open_issues   =~ m/$issue->{md5}/;
	return if $BITBUCKET->closed_issues =~ m/$issue->{md5}/;

	# Format title and body for creating issue
	# Title format: comment [basename of file], escape any '
	(my $filename = $issue->{file}) =~ s{\A.+/}{};
	my $title = "$issue->{comment} [$filename]";
	# [fixme] - Figure out how to escape ' character on JSON post
	# Remove ' for now
	$title =~ s/'//;
	# Since not JSON, need to replace spaces with +
	$title =~ s/\s/+/g;

	debugPrint("Formatted title for Bitbucket Post : $title\n");

	# %0D%0A at end so newlines will show up properly on Bitbucket
	my $body = "__filename__ : $issue->{file}%0D%0A%0D%0A  " .
				"__line #__ : $issue->{linenumber}%0D%0A%0D%0A  " .
				"__tag__ : $issue->{tag}%0D%0A%0D%0A  " .
				"__md5__ : $issue->{md5}%0D%0A%0D%0A  ";
	debugPrint("Formatted body for Bitbucket Post : $body\n");
	# Replace spaces with + like above
	$body =~ s/\s/+/g;

	# Format call, pass all params as -d to avoid \= \&
	my $call = sprintf "curl -s -i 'https://bitbucket.org/api/1.0/repositories/%s/issues' -d 'title=%s&content=%s' -u '%s:%s'", $BITBUCKET->repo, $title, $body, $BITBUCKET->api, $BITBUCKET->pw;
	# If you allow this to print below pw will show up as plain text!
	debugPrint("Formatted call for Bitbucket Post : $call\n");
	my $response = `$call`;
	debugPrint($response);
}


##########################
# Box glyph, e.g [!], [x]
##########################

sub box { join '', BOLD, "[ ", RESET, @_, RESET, BOLD, " ] ", RESET }

# often-used combinations:

sub box_ok    { join '', box(BOLD GREEN   "o"), BOLD @_, RESET }

sub box_info  { join '', box(BOLD YELLOW  "!"), BOLD @_, RESET }

sub box_warn  { join '', box(BOLD MAGENTA "!"), BOLD @_, RESET }

sub box_error { join '', box(BOLD RED     "x"), BOLD @_, RESET }

#########
# prompt
#########

sub prompt {
	my %config = (
		out => select(),
		in	=> \*STDIN,
		echo => 1,
		('HASH' eq ref $_[0])  ? %{ shift @_ } :
		('HASH' eq ref $_[-1]) ? %{ pop   @_ } :
		(),
	);
	print {$config{out}} @_;
	system 'stty', '-echo' unless $config{echo};
	chomp(my $answer = readline $config{in});
	system 'stty', 'echo'  unless $config{echo};
	return $config{default} if exists $config{default} and not length $answer;
	return $answer;
}

# kate: space-indent off; indent-width 4; mixedindent off; indent-mode cstyle;
